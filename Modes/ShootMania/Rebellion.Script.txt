/**
 *	Mode Rebellion
 */

#Extends "Modes/ShootMania/ModeTournament.Script.txt"

#Const	CompatibleMapTypes	"KArena"
#Const	Version				"2014-07-25"
#Const	ScriptName			"Melee.Script.txt"
#Const ModeName "Rebellion"

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib

// INCLUDES ------------------------- //
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen
// INCLUDES ------------------------- //
#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map
#Include "Libs/Time.Script.txt" as Chrono
#Include "Libs/Nadeo/ShootMania/WeaponSelection2.Script.txt" as WS

#Include "Libs/Nadeo/ShootMania/Debug.Script.txt" as Debug

// ---------------------------------- //
// Settings
// ---------------------------------- //
#Setting S_TimeRecapture 15 as _("Time to re-capture.")
#Setting S_TimeDefEliminated 20 as _("Time to capture the checkpoint when DefTeam is eliminated.")

/*
 * Apply different settings for this gamemode
 */
#Setting S_Mode 0 as _("0: Classic 1: Free")
#Setting S_TimeLimit	150
#Setting S_TimeCapture 4.

#Const C_Debug False

#Const C_DirectElimination False
#Const C_RespawnTime 20000

#Const C_RocketGain					1.		///< Rocket ammo regen speed
#Const C_LaserGain					0.9		///< Laser ammo regen speed

#Const C_Interface [
  "ST" => CUILayer::EUILayerType::ScoresTable,
  "Markers" => CUILayer::EUILayerType::Markers
]

#Const C_Weapon [
  "Rocket" => CSmMode::EWeapon::Rocket,
  "Laser" => CSmMode::EWeapon::Laser
]

// ---------------------------------- //
// Globales variables
// ---------------------------------- //
declare Boolean Mode_ThereIsAnAttacker;
declare Integer G_CheckpointsCount;
declare Integer G_CheckpointsCaptured;

***StartServer***
***
if (C_Debug) Debug::Load();
G_CustomMode = True;

ST2::SetStyle("LibST_SMBaseTeams");
ST2::SetStyle("LibST_SMWithLegends");
ST2::CreateCol("DefPoints", _("|Substantive|Hit"), "0", 3., 100.);
ST2::SetColTextAlign("DefPoints", CMlControl::AlignHorizontal::Right);
ST2::CreateCol("AtkPoints", _("|Attack,Substantive|Atk"), "0", 3., 110.);
ST2::SetColTextAlign("AtkPoints", CMlControl::AlignHorizontal::Right);
ST2::SetColTextSize("AtkPoints", 3.);
ST2::Build("SM");

G_ModeName = "Rebellion";
	
declare netwrite Text NameToWrite for Teams[0];
NameToWrite = G_ModeName;

CreateSpawnScreen("$f60»$z$sIn attack, you'll need to capture the central goal to be The Ultimate Attacker.\n$f60»$z$sWhen you are the attacker, you need to capture / kill all defenders. \n$f60»$z$sWhen you defend, you'll need to prevent the capture OR kill all attackers/The Ultimate Attacker !\n$f60»$z$sThe Ultimate Attacker got a markers.\n$f60»$z$sThe attackers have only one life and a Rail.");
***


***StartMap***
***
ClearScores();
Users_SetNbFakeUsers(1, 1);
ST2::ClearScores();

foreach (Player in Players) {
---Players_ClearScores---
}
***

***Init***
***
G_NextAtkName[1] = Teams[G_AtkClan-1].ColorizedName;
***

***InitVarMap***
***
G_CheckpointsCount = 0;

declare netwrite Text NameToWrite for Teams[0];
NameToWrite = G_ModeName;

Goals = CSmMapLandmark[];
declare EliminatedDef = 0;
declare SoundVariantDef = 0;
declare EliminatedAtk = 0;
declare SoundVariantAtk = 0;
declare PoleTime = 0;
declare GoalCanBeCaptured = False;
declare G_UIUpdate = Now + 100;
G_ReasonMessage1 = "";
G_ReasonMessage2 = "";
G_Reason = -1;
G_TiePoints = -1;
***

***StartMap***
***
foreach (MapLandmark in MapLandmarks_Gauge) {
	if (MapLandmark.Tag == "Goals") {
		G_CheckpointsCount += 1;
	}
}

declare G_Elimination = False;

declare Progression = 0;
***

***InitVarTurn***
***
G_Elimination = False;
G_DefClan = 3-G_AtkClan;
GoalCanBeCaptured = False;
foreach (Goal in Goals) Goal.Gauge.Clan = 3-G_AtkClan;

SoundVariantDef = 0;
SoundVariantAtk = 0;
EliminatedDef = -1;
EliminatedAtk = -1;

UIManager.UIAll.TeamLabelsVisibility = CUIConfig::ELabelsVisibility::Always;
UIManager.UIAll.TeamLabelsShowGauges = CUIConfig::EVisibility::ForcedHidden;
UIManager.UIAll.TeamLabelsShowNames = CUIConfig::EVisibility::ForcedHidden;
UIManager.UIAll.OpposingTeamLabelsVisibility = CUIConfig::ELabelsVisibility::Never;

Mode_ThereIsAnAttacker = False;
***

***StartTurn***
***
Interface::CreatePlayersLists("Small", 1., 10, 1);
UpdateMarkers();
Progression = 0;

if (WarmUp2::GetPlayersNb("Clan1") < 1 || WarmUp2::GetPlayersNb("Clan2") < 1) {
		G_Override_NeedWarmUp = True;
		WarmUp2();
		G_Override_NeedWarmUp = False;
}
***

***Mode_EndStartTurn1***
***
/*
 * Init Mode checkpoints settings
 */
foreach (Landmark in MapLandmarks_Gauge) {
	declare ReCapture for This.MapLandmarks_Gauge[Landmark] = False;
	if (Landmark.Tag == "Goals") {
		Landmark.Gauge.Max = (MathLib::NearestInteger(S_TimeCapture * 1000)) - (G_CheckpointsCount*1000);
		
		if (Landmark.Gauge.Max < 1000) {
			Landmark.Gauge.Max = MathLib::NearestInteger(S_TimeCapture * 1000);
		}
	}
	
	ReCapture = True;
	Landmark.Gauge.Value = 0;
	Landmark.Gauge.Clan = G_AtkClan;
	G_CheckpointsCaptured = 0;
}
***

***Mode_EndStartTurn2***
***
/*
 * Init Mode PlayersIds settings
 */
G_Attackers[1] = NullId;
UpdateMarkers();
***

***StartMap***
***
UpdateMarkers();
***

***SpawnAtk***
***
if (!Players.existskey(PlayerId)) continue;		
declare Player <=> Players[PlayerId];
declare CurrentWeapon for Player = 1;
SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_AtkRocketAmmoMax-2);
SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, C_AtkLaserAmmoMax);
SetPlayerAmmoMax(Player, CSmMode::EWeapon::Nucleus, C_AtkNucleusAmmoMax);

Player.StaminaMax	= 0.8;
Player.StaminaGain	= 1.;
Player.ArmorMax		= 100*DefSpawned;
CurrentWeapon = 2;
Player.AmmoGain		= 1. * C_AtkLaserAmmoGain;
SetPlayerWeapon(Player, CSmMode::EWeapon::Laser, False);
SM::SpawnPlayer(Player, G_AtkClan, AtkSpawn, Now);
Player.IsHighlighted = True;
AtkSpawned += 1;
***

***SpawnDef***
***
if (DefSpawned >= MaxDef) break;
if (!Players.existskey(PlayerId)) continue;

declare Player <=> Players[PlayerId];
declare CurrentWeapon for Player = 1;
CurrentWeapon = 1;
SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_DefRocketAmmoMax);
SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, C_DefLaserAmmoMax);
SetPlayerAmmoMax(Player, CSmMode::EWeapon::Nucleus, C_DefNucleusAmmoMax);

Player.AmmoGain		= 1. * C_DefRocketAmmoGain;
Player.StaminaMax	= 1. * C_DefStaminaMaxMultiplier;
Player.StaminaGain	= 1. * C_DefStaminaMaxMultiplier;
Player.ArmorMax		= 100;
SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, True); 
SM::SpawnPlayer(Player, G_DefClan, DefSpawn, Now);
Player.IsHighlighted = True;
DefSpawned += 1;
***

***Mode_OnCenterCapture***
***
Message::SendBigMessage(TextLib::Compose("$<%1$> captured the goal!", Players[G_Attackers[1]].Name), 3000, 10);
PlaySound(CUIConfig::EUISound::Capture, 0);
	
foreach (Player in Players) {
	if (Player.CurrentClan == G_AtkClan) {
		Message::SendStatusMessage("Help "^Players[G_Attackers[1]].Name^" !", 5000, 10);
		if (G_Attackers[1] != NullId && Player.Id == G_Attackers[1]) {
			Message::SendStatusMessage("Capture the checkpoints!", 8000, 10);
		}
	} else {
		Message::SendStatusMessage("Defend the checkpoints!", 5000, 10);
	}
}
UpdateMarkers();
***

***Event_OnCapture***
***
if (Players.existskey(G_Attackers[1]) && Event.Landmark.Tag == "Goals") {
	Message::SendBigMessage(TextLib::Compose("$<%1$> captured the checkpoint!", Players[G_Attackers[1]].Name), 3000, 10);
	PlaySound(CUIConfig::EUISound::Capture, 0);
	
	Points(Players[G_Attackers[1]], "Attack");
	
	Event.Landmark.Gauge.Clan = G_AtkClan;
	Event.Landmark.Base.Clan = G_AtkClan;
	
	declare ReCapture for This.MapLandmarks_Gauge[Event.Landmark] = False;
	ReCapture = False;
	
	G_CheckpointsCaptured += 1;
	
	foreach (Player in Players) {
	// Add armors
	if (Player.CurrentClan == G_AtkClan) {
	Player.ArmorMax = (G_CheckpointsCaptured*100) + (100*DefSpawned);
	Player.Armor += 100;
	}
	
	// Spawn the atkplayers who were eliminated
	declare AtkSpawn <=> Map::GetPlayerSpawn("Spawn", 1);
	declare DefSpawn <=> Map::GetPlayerSpawn("Spawn", 2);
	declare OrderAtk = WarmUp2::GetGroup("Clan"^G_AtkClan);
	OrderAtk = WarmUp2::GetGroup("Clan"^G_AtkClan);
	
	// Spawn them
	if (!G_Elimination &&
	Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && G_CheckpointsCaptured < G_CheckpointsCount) {
	if (Player.CurrentClan == G_AtkClan) { SM::SpawnPlayer(Player, G_AtkClan, AtkSpawn, Now+1000);
		EliminatedAtk -= 1;
	}
	else { SM::SpawnPlayer(Player, G_DefClan, DefSpawn, Now+1000);
		EliminatedDef -= 1;
	}

	}
}
	
	foreach (MapLandmark in MapLandmarks_Gauge) {
		if (MapLandmark.Tag == "Central") {
			MapLandmark.Gauge.Max = (S_TimeRecapture*1000);
			MapLandmark.Gauge.Value = MapLandmark.Gauge.Max-100;
			MapLandmark.Gauge.Clan = G_DefClan;
			MapLandmark.Gauge.Speed = -1;
		}
	}
	
	if (G_CheckpointsCaptured >= G_CheckpointsCount || (ClansNbPlayersAlive[G_DefClan] <= 0 && !C_DirectElimination)) {
		G_ReasonMessage2 = TextLib::Compose("$<%1$> captured the last pole.", Players[G_Attackers[1]].Name);
		G_WinningTurn = G_AtkClan;
		MB_StopTurn = True;
	}
	
	Mode_ThereIsAnAttacker = False;
	G_Attackers[1] = NullId;
	Progression = 0;
}
UpdateMarkers();
***

***TournamentLoop***
***
foreach (Goal in MapLandmarks_Gauge) {
	if (Goal.Gauge.Clan == G_DefClan && Goal.Tag == "Central" && !G_Elimination) {	
		//UIManager.UIAll.StatusMessage = MathLib::NearestInteger((Goal.Gauge.Value) * 0.001)^" seconds before re-capture.";
		UIManager.UIAll.CountdownEndTime = Now+Goal.Gauge.Value;
		if (Goal.Gauge.Value <= 0) {
			Goal.Gauge.Clan = G_AtkClan;
			UIManager.UIAll.CountdownEndTime = -1;
			UIManager.UIAll.StatusMessage = "";
			Message::SendBigMessage("The goal can now be captured again!", 5000, 10, CUIConfig::EUISound::PhaseChange, 0);
			UpdateMarkers();
		}
	}
}

foreach (Goal in MapLandmarks_Gauge) {

declare ReCapture for This.MapLandmarks_Gauge[Goal] = False;

	if (!Goal.Gauge.Captured && Goal.Tag == "Central" && Goal.Gauge.Clan == G_AtkClan) {
		foreach (PlayerId in Goal.Sector.PlayersIds) {
			declare Player <=> Players[PlayerId];
			
			if (Player.CurrentClan == G_AtkClan && !Goal.Gauge.Captured && Goal.Gauge.Value <= 0 && Progression <= 0) {
			G_Attackers[1] = Player.Id;
			Mode_ThereIsAnAttacker = True;
			Goal.Gauge.Speed = 0;
			Goal.Gauge.Captured = True;
			Goal.Gauge.Value = Goal.Gauge.Max;
			
			Goal.Gauge.Clan = G_AtkClan;
			
			+++Mode_OnCenterCapture+++
			
			Progression += 1;
			}
		}
	} else if (!Goal.Gauge.Captured && Goal.Tag == "Goals" && Goal.Gauge.Clan == G_AtkClan && ReCapture) {
	if (Goal.Sector.PlayersIds.exists(G_Attackers[1])) Goal.Gauge.Speed = 1;
	else Goal.Gauge.Speed = 0;
	}
	
	if (Goal.Sector.PlayersIds.count == 0 && Goal.Gauge.Clan == G_AtkClan) Goal.Gauge.Speed = 0;
}

if (C_Debug) Debug::Loop();

foreach (Player in Players) { BlockPoleInfo(This.Players[Player]);
	if (Player.CurrentClan == G_DefClan &&
	Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
	declare DefSpawn <=> Map::GetPlayerSpawn("Spawn", 2);
	declare RespawnTime for Player = 0;
		if (RespawnTime < Now) {
			SM::SpawnPlayer(Player, G_DefClan, DefSpawn, Now+1000);
			RespawnTime = Now;
			EliminatedDef -= 1;
			declare UI for Player <=> UIManager.GetUI(Player);
			if (UI != Null) UI.StatusMessage = "";
		} else {
			declare UI for Player <=> UIManager.GetUI(Player);
			if (UI != Null) UI.StatusMessage = (RespawnTime-Now)/1000^" seconds before respawn.";
		}
	}
}

if (ClansNbPlayersAlive[G_DefClan] <= 0 && !C_DirectElimination && !G_Elimination) {
	G_Elimination = True;
	UIManager.UIAll.CountdownEndTime = -1;
	EndTime = Now + (S_TimeDefEliminated*1000);
	UIManager.UIAll.CountdownEndTime = -1;
	
	foreach (Goal in MapLandmarks_Gauge) {
	Goal.Gauge.Clan = G_AtkClan;
	Goal.Gauge.Value = 0;
	}
	
	UIManager.UIAll.BigMessage = "All defenders eliminated, capture a checkpoint!";
}

if (ClansNbPlayersAlive[G_DefClan] <= 0 && C_DirectElimination) MT_StopTurn(C_DefElimination);
if (ClansNbPlayersAlive[G_AtkClan] <= 0) MT_StopTurn(C_AtkElimination);
if (AtkEliminated() && Mode_ThereIsAnAttacker) MT_StopTurn(C_UltimateElimination);
***

***OnRequestRespawn***
***
declare RespawnTime for Event.Player = Now;
RespawnTime = Now + C_RespawnTime;
UnspawnPlayer(Event.Player);
***

***Event_OnHit***
***
Points(Event.Shooter, "Defend");
if (Event.Victim.CurrentClan == G_DefClan) { //< Eliminate a standart defenser
	Event.Damage = 100;
	SoundVariantDef += 1;
	EliminatedDef += 1;

	
	declare Distance = MathLib::Distance(Event.Shooter.Position, Event.Victim.Position);
	Distance = MathLib::NearestInteger(Distance*10.0)/10.0;
	declare DistanceText = TextLib::SubString(TextLib::ToText(Distance), 0, 5);
	declare DistanceSplit = TextLib::Split(".", DistanceText);
	
	if (Event.Shooter.CurWeapon == C_WeaponLaser) NoticeHitDistance(Event.Shooter,
	   TextLib::Compose(_("%1m !"), DistanceText));
// Elim last defenders
	if (ClansNbPlayersAlive[G_DefClan] <= 1 || EliminatedDef-1 >= ClansNbPlayersAlive[G_DefClan]) {
		PlaySound(CUIConfig::EUISound::VictoryPoint, 0);
	} 
	// Elim standard defenders
	else {
		PlaySound(CUIConfig::EUISound::TieBreakPoint, SoundVariantDef);
	}
	
	declare RespawnTime for Event.Victim = Now;
	RespawnTime = Now + C_RespawnTime;
			
	if (ClansNbPlayersAlive[G_DefClan] > 1) {
		declare DefLeft = ClansNbPlayersAlive[G_DefClan] - 1;
		if (DefLeft <= 1) {
			Message::SendStatusMessage(
				TextLib::Compose(
					"%1%2", 
					Teams[G_DefClan - 1].ColorText,
					_("1 defender left.")
				), 3000, 2
			);
		} else {
			Message::SendStatusMessage(
				TextLib::Compose(
					_("%1 %2 defenders left."), 
					Teams[G_DefClan - 1].ColorText, 
					TextLib::ToText(DefLeft)
				), 3000, 2
			);
		}
	}
} else { //< Eliminate a standart defenser

	Event.Damage = 100;
	SoundVariantAtk += 1;
	if (Event.Victim.Id != G_Attackers[1]) EliminatedAtk += 1;
	
	if (Event.Shooter.CurWeapon == C_WeaponLaser) NoticeHitDistance(Event.Shooter,
	   TextLib::Compose(_("%1m hit!")));
// Elim last attackers/ultimate
    if (Event.Victim.Armor <= 100) {
	if (ClansNbPlayersAlive[G_AtkClan] <= 1 || EliminatedAtk-1 >= ClansNbPlayersAlive[G_AtkClan] || Event.Victim.Id ==
	G_Attackers[1]) {
		PlaySound(CUIConfig::EUISound::VictoryPoint, 0);
	} 
	// Elim standard defenders
	else {
		PlaySound(CUIConfig::EUISound::TiePoint, SoundVariantAtk);
	}
			
	if (ClansNbPlayersAlive[G_AtkClan] > 1) {
		declare AtkLeft = ClansNbPlayersAlive[G_AtkClan] - 1;
		if (AtkLeft <= 1) {
			Message::SendStatusMessage(
				TextLib::Compose(
					"%1%2", 
					Teams[G_AtkClan - 1].ColorText,
					_("1 attacker left.")
				), 3000, 2
			);
		} else {
			Message::SendStatusMessage(
				TextLib::Compose(
					_("%1 %2 attackers left."), 
					Teams[G_AtkClan - 1].ColorText, 
					TextLib::ToText(AtkLeft)
				), 3000, 2
			);
		} }
	}
}
PassOn(Event);
***

***StartEndTurn***
***
UIManager.UIAll.BigMessage = "";
UIManager.UIAll.StatusMessage = "";
***

***CompleteEndTurn***
***
Interface::DestroyPlayersLists();
***

***DeleteVarMap***
***
EliminatedDef = 0;
SoundVariantDef = 0;
EliminatedAtk = 0;
SoundVariantAtk = 0;
PoleTime = 0;
GoalCanBeCaptured = False;
G_UIUpdate = Now + 100;
G_ReasonMessage1 = "";
G_ReasonMessage2 = "";
MT_QuickStop = False;

Goals.clear();
***

Void Points(CSmPlayer _Helped, Text _Input) {
    if (_Input == "Attack") {
	declare Atk_Points for _Helped = ["Attack" => 0];
	Atk_Points["Attack"] += 1;
	ST2::SetColValue("AtkPoints", _Helped.Score, TextLib::ToText(Atk_Points["Attack"]));
	} else {
	declare Def_Points for _Helped = ["DefPoints" => 0];
	Def_Points["DefPoints"] += 1;
	ST2::SetColValue("DefPoints", _Helped.Score, TextLib::ToText(Def_Points["DefPoints"]));	
	}
}

Void BlockPoleInfo(CSmPlayer Player) {
declare UI for Player = UIManager.GetUI(Player);

	if (Player.BlockPole != Null && UI != Null) {
	declare ReCapture for This.MapLandmarks_Gauge[Player.BlockPole] = False;
		declare BlockPole <=> Player.BlockPole;
		UI.GaugeRatio = BlockPole.Gauge.ValueReal;
		UI.GaugeClan = G_AtkClan;
		
		if (BlockPole.Tag == "Goals" && !ReCapture)
		{
		UI.GaugeMessage = "Already captured.";
		} else {
		UI.GaugeMessage = "" ^ MathLib::FloorInteger(BlockPole.Gauge.ValueReal*100) ^ "%";
		}
		
	} else { UI.GaugeRatio = -1000.;
	UI.GaugeClan = -1;
	UI.GaugeMessage = ""; }
}

Void UpdateMarkers() {
	// Set the marker above the goal
	UIManager.UIAll.MarkersXML = "";
	
	declare AtkPlayerLogin = [1 => ""];
	if (Players.existskey(G_Attackers[1])) AtkPlayerLogin[1] = Players[G_Attackers[1]].Login;
	
	declare NucleusMarker = "";
	if (AtkPlayerLogin[1] != "") {
		NucleusMarker = """<marker icon="Player3" color="{{{TextLib::ColorToText(Teams[G_AtkClan-1].ColorPrimary)}}}" playerlogin="{{{AtkPlayerLogin[1]}}}" box="0 2 0" />""";
	}
	
	declare PolesMarker = "";
	foreach (LandmarkGauge in MapLandmarks_Gauge) {
	declare ReCapture for This.MapLandmarks_Gauge[LandmarkGauge] = False;
		declare Icon = "";
		declare Name = "";
		declare Pos = 0;
		declare IMG = "file://Media/Manialinks/ShootMania/Common/";
		declare IMG2 = "";
		if (LandmarkGauge.Tag == "Central") { Name = "$s$oCentral"; Pos = 25;
		IMG2 = "target.dds";
		if (LandmarkGauge.Gauge.Value > 0) IMG2 = "c_goal_shield_block.dds"; }
		else if (LandmarkGauge.Tag == "Goals" && ReCapture) { Name = "$o$sCheckpoints"; Pos = 5;
		IMG2 = "c_goal_capture.dds"; }
		else if (LandmarkGauge.Tag == "Goals" && !ReCapture) { Name = "$o$sCheckpoints"; Pos = 5;
		IMG2 = "c_goal_captured.dds"; }
		else continue;
		PolesMarker ^= """<marker imageurl="{{{IMG^IMG2}}}" color="{{{TextLib::ColorToText(Teams[2-G_AtkClan].ColorPrimary)}}}" pos="{{{LandmarkGauge.Position.X}}} {{{LandmarkGauge.Position.Y + Pos}}} {{{LandmarkGauge.Position.Z}}}" />""";
	}
		
	foreach (Player in Players) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		
		if (Player.Login != AtkPlayerLogin[1]) {
			UI.MarkersXML = NucleusMarker ^ PolesMarker;
		} else {
			UI.MarkersXML = PolesMarker;
		}
	}
	foreach (Spectator in Spectators) {
		declare UI <=> UIManager.GetUI(Spectator);
		if (UI == Null) continue;
		UI.MarkersXML = PolesMarker ^ NucleusMarker;
	}
}
