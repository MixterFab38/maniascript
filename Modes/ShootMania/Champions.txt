// Generated ManiaScript (HSTOMS)

#Extends "Modes/ShootMania/Base/ModeMatchmaking.Script.txt"

#Include "Libs/Nadeo/Victory.Script.txt" as Victory
#Include "Libs/Nadeo/ShootMania/WarmUp2.Script.txt" as WarmUp2
#Include "Libs/Nadeo/Json.Script.txt" as Json
#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map
#Include "Libs/Nadeo/ShootMania/Toss.Script.txt" as Toss
#Include "Libs/Nadeo/ShootMania/WaitingQueue.Script.txt" as WQ
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Debug.Script.txt" as Debug
#Include "Libs/Nadeo/Interface.Script.txt" as Interface

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib

#Setting S_WarmUpDuration 60
#Setting S_NbPlayersPerTeamMax 4 as _("Number of Players Per Team")
#Setting S_TurnWin 10
#Setting S_TurnGap 2
#Setting S_TurnMax 15
#Setting S_MatchWin 2
#Setting S_MatchGap 2
#Setting S_MatchMax 4
#Setting S_TimeLimit 50
#Setting S_TimeCapture 20
#Setting S_TimeToCap 3.
#Setting S_BonusTime 15
#Setting S_MaxGoals 3
#Setting S_DelayCapture 10

#Const  CompatibleMapTypes  "gesArena, HeroesArena, EliteArena"
#Const  Version       "2017-03-08"
#Const  ScriptName      "Champions.Script.txt"

#Const C_Debug True
#Const C_UseCustomEndTime False

/*
 * ENUMS
 */
#Const E_Preparation_Warmup 0
#Const E_Preparation_WinningSequence 1
#Const E_Preparation_IntroOutro 2
#Const E_Preparation_Playing 3

#Const E_Mode_Classic 0

#Const E_AtkSelection_Laser 0
#Const E_AtkSelection_Rocket 1
#Const E_AtkSelection_Nucleus 2

declare Integer[Integer] MapScores;
declare CSmMapLandmark[Integer] KnowGoals;
declare CSmMapLandmark[Integer] TeamSpawns;
declare CSmMapGauge[] GaugeLandmarks;
declare CSmMapBase[] BaseLandmarks;
declare Integer CurrAtkClan;
declare Boolean CanStartNewMatch;
declare Integer Round_WinningClan;
declare Integer MapWinner;
declare Integer[Integer][Integer] AttackersSlot;
declare Ident[Integer] IDAttackers;
declare CSmPlayer ShieldPlayer;
declare Integer LastShieldTime;
declare Integer DefenderCount;
declare Integer PoleTime;
declare Boolean GoalCanBeCaptured;
declare CSmMapLandmark LastGoalCaptured;
declare Integer Coroutine_DefenderRespawn;
declare Integer Coroutine_CaptureGoal;
declare Boolean GotCaptured;

// Private
declare Integer lastNbDefAlive;
declare Boolean WarmUp_Set;
declare Boolean isRematch;
declare Integer rematchCount;

***Rules***
***
/* -------------------------------------- */
// Create rules
	declare ModeName = "Champions";
	declare ModePreInfo = TextLib::Compose(_("$<%11. $>At every turn, 2 new Champions are selected and they battle against %5 defenders.\n$<%12. $>The Champions got much armors as the count of total Defenders\n$<%13. $>One Champion got one RailGun and the other got 4 Rockets.\n$<%14. $>One of the defender got a Nucleus."), "$"^SpawnScreen::GetModeColor(), TextLib::ToText(S_TimeLimit - S_TimeToCap), TextLib::ToText(S_TimeLimit), TextLib::ToText(S_TurnWin), TextLib::ToText(S_NbPlayersPerTeamMax));
declare ModeConditions = TextLib::Compose(_("$<%11. $>The team in defense play with Rockets.\n$<%12. $>The team in attack play with 4 Lasers and 1 Nucleus.\n$<%13. $>The player with the Nucleus is the attacker and is the only one who can capture a pole.\n$<%14. $>If the attacker is eliminated, his team lose the turn."), "$"^SpawnScreen::GetModeColor());
	declare ModeObjectives = TextLib::Compose(_("$<%11. $>Champions need to capture all poles!\n$<%12. $>To capture a pole, kill all defenders OR capture them when you can.\n$<%13. $>If you kill all defenders, they will respawn but your ally and you will got armors to the maximum!\n$<%14. $>But if you only capture, defenders will not respawn BUT yours armors will be replanished"), "$"^SpawnScreen::GetModeColor());

	SpawnScreen::ResetRulesSection();
	SpawnScreen::AddSubsection(_("Type"), _("Team versus Team"), 0.);
	SpawnScreen::AddSubsection(
		_("Pre-Informations"), 
		ModePreInfo, 
		25.
	);
	SpawnScreen::AddSubsection(
		_("Objectives"), 
		ModeObjectives, 
		65.
	);
	SpawnScreen::AddSubsection(
		_("Conditions"), 
		"", 
		105.
	);
	SpawnScreen::CreatePrettyRules(ModeName, False);

	ModeStatusMessage = _("TYPE: Team versus Team (4 vs 4)\nOBJECTIVE: Capture the pole when you're the attacker. Defend the pole when you're a defender.");
***

***LoadLibrairies***
***
	log("Loading | " ^ WarmUp2::GetScriptName() ^ " : " ^ WarmUp2::GetScriptVersion() ^"");
	{
		WarmUp2::Load();
		for (i, 1, 2)
			WarmUp2::CreateGroup("Clan" ^ i, S_NbPlayersPerTeamMax);
		WarmUp2::DisplayClanSelection(True);
	}
	
	MB_UseSectionRound = True;
	MB_UseSectionTurn = True;
	
	ST2::SetStyle("LibST_SMBaseTeams");
	ST2::SetStyle("LibST_SMWithLegends");
	ST2::CreateCol("DefPoints", _("|Substantive|Hit"), "0", 3., 100.);
	ST2::SetColTextAlign("DefPoints", CMlControl::AlignHorizontal::Right);
	ST2::CreateCol("AtkPoints", _("|Attack,Substantive|Atk"), "0", 3., 110.);
	ST2::SetColTextAlign("AtkPoints", CMlControl::AlignHorizontal::Right);
	ST2::SetColTextSize("AtkPoints", 3.);
	ST2::Build("SM");
	
	Layers::Create("Champions_CaptureGauge", Layer_CaptureGauge());
***

***LobbyStartServer***
***
	MM_SetFormat([S_NbPlayersPerTeamMax, S_NbPlayersPerTeamMax]);
***

***StartServer***
***
	log(ServerLogin);
	
	if (MM_IsMatchServer())
		MM_Init([S_NbPlayersPerTeamMax, S_NbPlayersPerTeamMax]);

	UseClans = True;
	CurrAtkClan = 1;
	
	rematchCount = 0;
	isRematch = False;
	
	MapScores = [1 => 0, 2 => 0];
	AttackersSlot = [
	 1 => 
		[Integer => 0],
	 2 =>
	 	[Integer => 0],
	 3 => 
		[Integer => 0]
	];
	
	for (C, 1, 2)
	{
		AttackersSlot[C][E_AtkSelection_Laser] = 1;
		AttackersSlot[C][E_AtkSelection_Rocket] = 1;
		AttackersSlot[C][E_AtkSelection_Nucleus] = 1;
	}
	
	CanStartNewMatch = True;
	
	// Load Librairies
	+++LoadLibrairies+++
	+++Rules+++
	
	Users_SetNbFakeUsers(2, 3);
	
	UIManager.UIAll.NoticesFilter_HideMapInfo = True;
	UIManager.UIAll.NoticesFilter_LevelToShowAsBigMessage = CUIConfig::ENoticeLevel::MatchInfo;
	
	UpdateHeader();
***

***StartMap***
***
	// Let's clear everything
	ResetLandmarks();
	// Let's sleep a little before
	MB_Sleep(1);
	
	for (i, 1, 2)
		ClanScores[i] = 0;
		
	UpdateHeader();
	
	WarmUp_Set = False;
	
	// Prepare the battle field!
	PrepareField(E_Preparation_Warmup);
	WarmUp(False);
	
	// ---------------------------------- //
	// Wait players when using matchmaking
	if (MM_IsMatchServer()) 
	{
		if (!isRematch) 
		{
			MM_MatchWait();
		} 
		else 
		{
			MM_WaitPlayers(15000);
		}
	}
	
	// ---------------------------------- //
	// Allow substitutes
	if (MM_IsMatchServer()) 
		MM_AllowSubstitutes(True);
		
	if (CanStartNewMatch)
		StartMatch();
		
	Victory::RoundBegin();
	Victory::MatchBegin();
	
***

***StartTurn***
***
	// Seriously?
	// We can't have brackets without statement?
	if (1 == 1) 
	{
		declare noEnoughtPlayer = 0;
		for (i, 1, 2)
			if (ClansNbPlayers[i] <= 1)
				noEnoughtPlayer += 1;
		if (noEnoughtPlayer >= 1)
		{
			UIManager.UIAll.SendChat("Can't start the match! (no enought players)");
			UIManager.UIAll.SendChat("(2vs2 min)\nBlue " ^ ClansNbPlayers[1] ^ " - Red " ^ ClansNbPlayers[2] ^ " players");
			
			Round_WinningClan = 0;
			MB_StopTurn = True;
			WarmUp_Set = True;
		}
	}

	if (WarmUp_Set)
	{
		WarmUp(True);
	}

	PrepareField(E_Preparation_IntroOutro);
	declare soundVariantAttack for This = 0;
	soundVariantAttack = 0;
	declare kill_serie for This = 0;
	kill_serie = 0;
	
	UIManager.UIAll.BigMessage = "";
	UIManager.UIAll.StatusMessage = "";

	ChooseAttackers();
	ChangeSlotOrder();
	
	MB_Sleep(1000);
	
	UIManager.UIAll.BigMessage = "";
	declare TeamAtkName = Teams[CurrAtkClan - 1].ColorizedName;
	declare TeamDefName = Teams[(3 - CurrAtkClan) - 1].ColorizedName;
	Message::SendBigMessage(TextLib::Compose(
		_("$<%1$> attack - defense $<%2$>"), 
		TeamAtkName, 
		TeamDefName
	), 4000, 10);
	
	DefenderCount = 0;
	foreach (player in Players)
	{
		if (player.CurrentClan == 3 - CurrAtkClan)
		{
			DefenderCount += 1;
		}
	}
	
	SpawnThemAll();
	
	StartTime = Now;
	EndTime = -1;
	
	PrepareField(E_Preparation_Playing);
	MB_Sleep(500);
	
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	
	foreach (player in Players)
	{
		if (player.CurrentClan == CurrAtkClan)
		{
			Message::SendStatusMessage(player,
				TextLib::Compose("Champions: R: $<%1$>, L: $<%2$>", Players[IDAttackers[E_AtkSelection_Rocket]].Name, Players[IDAttackers[E_AtkSelection_Laser]].Name
				), 4000, 10);
		}
		else
		{
			Message::SendStatusMessage(player,
				TextLib::Compose("Nucleus: $<%1$>", Players[IDAttackers[E_AtkSelection_Nucleus]].Name
				), 4000, 10);
		}
	}
	
	PoleTime = (StartTime + (S_TimeLimit - S_TimeCapture) * 1000);
	
	foreach (goal in KnowGoals)
	{
		goal.Gauge.Max = PoleTime - Now;
		goal.Gauge.Value = goal.Gauge.Max;
	}
		
	UIManager.UIAll.CountdownEndTime = PoleTime;
		
	GoalCanBeCaptured = False;
	
	EndTime = (StartTime + (S_TimeLimit) * 1000);
	
	UpdateHeader();
	
	Coroutine_CaptureGoal = -1;
	
	GotCaptured = False;
	
	View(NullId);
	Coroutine_DefenderRespawn = -1;
	
	lastNbDefAlive = -1;
***

***Yield***
***
	Message::Loop();
	Layers::Attach("Champions_CaptureGauge");
***

***UpdateGoals***
***
	foreach (i => goal in KnowGoals)
	{
		if (Now <= PoleTime && !GotCaptured)
			goal.Gauge.Speed = -1;
		else if (GoalCanBeCaptured)
		{
			declare gotRocket = False;
			declare gotLaser = False;
			foreach (playerId in goal.Sector.PlayersIds)
			{
				declare player <=> Players[playerId];
				
				if (!gotRocket)
					gotRocket = playerId == IDAttackers[E_AtkSelection_Rocket];
				if (!gotLaser)
					gotLaser = playerId == IDAttackers[E_AtkSelection_Laser];
			}
			
			
			if (gotRocket && gotLaser)
				goal.Gauge.Speed = 1;
			else 
				goal.Gauge.Speed = 0;
		}
		
		/*if (goal.Gauge.Value == goal.Gauge.Max && !goal.Gauge.Captured)
			goal.Gauge.Captured = True;*/
	}
	
	if (Now >= PoleTime)
	{
		if (!GoalCanBeCaptured)
		{
    		UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::PhaseChange;
   			UIManager.UIAll.BigMessageSoundVariant = 0;
    		UIManager.UIAll.BigMessage = _("Capture the poles of the opposing team!");
    		UIManager.UIAll.CountdownEndTime = -1;	

			if (!GotCaptured)
			{
				foreach (i => goal in KnowGoals)
				{
					goal.Gauge.Clan = CurrAtkClan;
					goal.Gauge.Value = 0;
					goal.Gauge.Max = MathLib::NearestInteger((S_TimeToCap/KnowGoals.count)*1000);
				}	
			}
			
			GoalCanBeCaptured = True;
		}		
	}
***

***OnShield***
***
	/*if (ShieldPlayer != Null)
	{
		Message::SendStatusMessage(ShieldPlayer, "Shield Removed by change", 3000, 5);
	}

	ShieldPlayer = event.Victim;
	LastShieldTime = Now;
	
	Message::SendStatusMessage(ShieldPlayer, "Armor Shield!", S_ShieldTime * 1000, 11);*/
	log("");
***

***UpdateEvents***
***
	if (event.Type == CSmModeEvent::EType::OnPlayerRequestRespawn)
		PassOn(event);

	if (event.Type == CSmModeEvent::EType::OnCapture)
	{
		declare landmark <=> event.Landmark;
		CaptureGoal(landmark);
		landmark.Gauge.Captured = True;
		
		PassOn(event);
	}
	if (event.Type == CSmModeEvent::EType::OnArmorEmpty)
	{
		declare vIsAtk = event.Victim.CurrentClan == CurrAtkClan; 
		declare defLeft = ClansNbPlayersAlive[3 - CurrAtkClan] - 1;
		declare lastEliminationTime for This = -1;
		declare kill_serie for This = 0;
		
		if (lastEliminationTime == Now && !vIsAtk)
		{
			defLeft -= 1 + kill_serie;
			kill_serie += 1;
		}
		else if (!vIsAtk)
			kill_serie = 0;
			
		if (!vIsAtk)
			lastEliminationTime = Now;
		else
		{
			// Eliminated an attacker
			Message::SendBigMessage(_("All attackers eliminated!"), 3000, 10);
			View(event.Shooter.Id);
		}
		
		if (defLeft <= 0 && event.Victim.CurrentClan == 3 - CurrAtkClan)
		{
			// See PlayLoop
			
			PassOn(event);
		}
		else
			PassOn(event);
	}
	if (event.Type == CSmModeEvent::EType::OnHit)
	{
		declare vIsAtk = event.Victim.CurrentClan == CurrAtkClan;
		declare armorLeft = event.Victim.Armor / 100;
		declare soundVariantAttack for This = 0;
		declare discarded = False;
		soundVariantAttack += 1;
		
		event.Damage = 100;
		
		if (event.Victim == event.Shooter)
		{
			Discard(event);
		}
		else if (event.Victim.CurrentClan == CurrAtkClan
		&& event.Victim.CurrentClan == event.Shooter.CurrentClan)
		{
			Discard(event);
		}
		else
		{
			if (vIsAtk)
			{
				if (event.Victim.Armor > 100)
				{
					Message::SendStatusMessage(
						TextLib::Compose(
							_("%1 %2 armors left."), 
							Teams[CurrAtkClan - 1].ColorText, 
							TextLib::ToText(armorLeft)
						), 3000, 2
					);
				}
				else
				{
					Message::SendStatusMessage(
						TextLib::Compose(
							"%1%2", Teams[CurrAtkClan - 1].ColorText, _("1 armor left.")
						), 3000, 2
					);					
				}
			}
			else
			{
				if (event.Shooter.CurrentClan == event.Victim.CurrentClan)
				{
					discarded = True;
					if (event.Shooter.Id == IDAttackers[E_AtkSelection_Nucleus])
					{
						+++OnShield+++
						event.Damage = 0;
						Discard(event);
					}
					else
						Discard(event);
				}
				
				if (event.Victim == ShieldPlayer)
				{
					Message::SendStatusMessage(ShieldPlayer, "Shield Removed by hit", 3000, 5);
					ShieldPlayer = Null;
					
					event.Damage = 0;
				}
					
				if (!discarded)
				{
				}
			}
			
			if (!discarded)
				PassOn(event);
		}	
	}
***

***PlayLoop***
***
	UpdateMarkers(False);
	
	+++UpdateGoals+++
	
	foreach (event in PendingEvents)
		{ +++UpdateEvents+++ }
		
	declare lastEliminationTime for This = 0;
	if (lastEliminationTime != Now)
	{
		declare kill_serie for This = 0;
		kill_serie = 0;
	}
	
	if (ShieldPlayer != Null)
	{
		ShieldPlayer.HasShield = False;
		ShieldPlayer.IsHighlighted = False;
	
		/*if (LastShieldTime + (S_ShieldTime * 1000) < Now)
		{
			Message::SendStatusMessage(ShieldPlayer, "Shield Removed by time", 3000, 5);
			ShieldPlayer = Null;
		}*/
	}
	else
	{
		foreach (player in Players)
		{
			player.HasShield = True;
			player.IsHighlighted = True;
		}
	}
	
	if (ClansNbPlayersAlive[3 - CurrAtkClan] != lastNbDefAlive)
	{
		lastNbDefAlive = ClansNbPlayersAlive[3 - CurrAtkClan];
		
		if (lastNbDefAlive <= 1)
		{
			Message::SendStatusMessage(
				TextLib::Compose(
					"%1%2", 
					Teams[2 - CurrAtkClan].ColorText,
					_("1 defender left.")
					), 3000, 2
				);
			}
		else
		{
			Message::SendStatusMessage(
				TextLib::Compose(
					_("%1 %2 defenders left."), 
					Teams[2 - CurrAtkClan].ColorText, 
					TextLib::ToText(lastNbDefAlive)
				), 3000, 2
			);			
		}		
		
		if (lastNbDefAlive <= 0)
		{
			
			PoleTime = Now - 1000;
			
			log(get_nearestGoalLeft().Tag ^ " o: " ^ get_nearestGoalLeft().Order);
			if (get_CapturedGoals() < get_MaxGoals())
				Coroutine_DefenderRespawn = Now + 1;
			
			get_nearestGoalLeft().Gauge.Speed = 0;
			
			Coroutine_CaptureGoal = Now + 2;
			
			Message::SendStatusMessage(_("All defenders eliminated!"), 4000, 10);
			
			foreach (player in Players)
				if (player.CurrentClan == CurrAtkClan)
					player.Armor = player.ArmorMax;
		}
	}
		
	if (EndTime < Now)
	{
		Round_WinningClan = 3 - CurrAtkClan;
		MB_StopTurn = True;
	}
	
	if (ClansNbPlayersAlive[CurrAtkClan] <= 1)
	{
		Round_WinningClan = 3 - CurrAtkClan;
		MB_StopTurn = True;
	}
	
	if (ClansNbPlayersAlive[3 - CurrAtkClan] == 0 && get_CapturedGoals() == get_MaxGoals())
	{
		Round_WinningClan = CurrAtkClan;
		MB_StopTurn = True;
	}
	if (ClansNbPlayers[3 - CurrAtkClan] <= 0)
	{
		Round_WinningClan = CurrAtkClan;
		MB_StopTurn = True;	
		WarmUp_Set = True;
	}
		
	if (Coroutine_DefenderRespawn < Now
		&& Coroutine_DefenderRespawn != -1)
	{
		Coroutine_DefenderRespawn = -1;

		foreach (player in Players)
			if (player.CurrentClan == 3 - CurrAtkClan)
			{
				declare grade = -1;
				if (player.Id == IDAttackers[E_AtkSelection_Nucleus])
					grade = 2;
				_SpawnPlayer(player.CurrentClan, grade, player);
			}
	}
	
	if (Coroutine_CaptureGoal < Now
		&& Coroutine_CaptureGoal != -1)
	{
		Coroutine_CaptureGoal = -1;
	
		CaptureGoal(get_nearestGoalLeft());
	}
***

***StartWarmUp***
***
	if (!CanStartNewMatch)
	{
		for (Count, 1, 2) 
		{
			WarmUp2::SetSlotIcon("Clan"^Count, AttackersSlot[Count][E_AtkSelection_Laser], "file://Media/Manialinks/ShootMania/Common/LaserWhite.dds");
			WarmUp2::SetSlotIcon("Clan"^Count, AttackersSlot[Count][E_AtkSelection_Rocket], "file://Media/Manialinks/ShootMania/Common/RocketWhite.dds");
		}
	}
	else
	{
		for (Count, 1, 2) 
		{
			WarmUp2::SetSlotIcon("Clan"^Count, 2, "file://Media/Manialinks/ShootMania/Common/LaserWhite.dds");
			WarmUp2::SetSlotIcon("Clan"^Count, 1, "file://Media/Manialinks/ShootMania/Common/RocketWhite.dds");
		}		
	}
***

***EndTurn***
***
	UpdateHeader();
	UpdateMarkers(False);
	
	if (Round_WinningClan != 0)
		ClanScores[Round_WinningClan] += 1;
	
	UIManager.UIAll.CountdownEndTime = -1;
	
	PlaySound(CUIConfig::EUISound::VictoryPoint, 0);
	
	MB_Sleep(100);
	
	EndTime = -1;
	
	if (LastGoalCaptured != Null && Round_WinningClan == CurrAtkClan)
		View(get_LastGoalId());
	
	MB_Sleep(500);
	UIManager.UIAll.BigMessage = "";
	UIManager.UIAll.StatusMessage = "";
	
	MB_Sleep(500);
	UnspawnLoosers();
	UpdateMarkers(False);
	MB_Sleep(2000);
	
	
	Message::CleanAllMessages();
	
	MB_Sleep(250);
	
	if (Round_WinningClan != 0)
		UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> wins the turn!"), Teams[Round_WinningClan - 1].ColorizedName);
	else
		UIManager.UIAll.BigMessage = _("Draw.");
	UpdateHeader();
	
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
	
	MB_Sleep(3000);
	SM::UnspawnAllPlayers();
	UpdateMarkers(False);
	
	MB_Sleep(1500);
	
	CurrAtkClan = 3 - CurrAtkClan;
	
	foreach (goal in KnowGoals)
		goal.Gauge.Speed = 0;
		
	UpdateHeader();
	
	Victory::SetMatchWinnerFromScore(S_TurnWin, S_TurnGap, S_TurnMax);

	for (i, 1, 2)
	{
		if (Victory::IsMatchWinner(i))
		{	MapWinner = i; MapScores[i] += 1; MB_StopMap = True; break; }
	}
	
	if (!MB_StopMap)
	{
		if (WarmUp_Set)
		{
			WarmUp(True);
		}
	}
***

***EndMap***
***
	MB_Sleep(1000);
	declare MatchWinner = get_MatchWinner();
	if (MatchWinner != 0)
		CanStartNewMatch = True;
	
	declare BlueTeam = Teams[0].ColorizedName;
	declare RedTeam = Teams[1].ColorizedName;
	
	UpdateHeader();
	
	if (!MatchEndRequested)
	{
		UIManager.UIAll.StatusMessage = TextLib::Compose("Map result: %1 %2 - %3 %4", BlueTeam, "" ^ MapScores[1], RedTeam, "" ^ MapScores[2]);
		UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> wins the map!"), Teams[MapWinner - 1].ColorizedName);
	
		MB_Sleep(6000);
		View(NullId);
		UIManager.UIAll.UISequence = CUIConfig::EUISequence::None;
		MB_Sleep(100);
	
		if (MatchWinner != 0)
		{
			UpdateHeader();
		
			UIManager.UIAll.StatusMessage = TextLib::Compose("$<%1$>: %3 - $<%2$>: %4", BlueTeam, RedTeam, "" ^ MapScores[1], "" ^ MapScores[2]);
			UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> wins the match!"), Teams[MapWinner - 1].ColorizedName);
		
			MapScores = [1 => 0, 2 => 0];
		
			UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
			MB_Sleep(4000);
		}
		else if (S_MatchWin <= 0 || (S_MatchWin <= 1 && S_MatchGap <= 1))
		{
			UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
			MB_Sleep(4000);
		}
	}
	else
	{
		Message::CleanAllMessages();
		UIManager.UIAll.StatusMessage = "";
		UIManager.UIAll.BigMessage = _("Change map");
		CustomSleep(1000);
		UIManager.UIAll.BigMessage = "";
	}
	
	declare Text MasterLogin;
	
	if (Scores.count > 0)
		MasterLogin = Scores[0].User.Login;
	
	if (MM_IsMatchServer()) 
	{
		MM_SetLadderMatchId();
		if (!MM_RestartMatchmaking) 
		{
			if (MB_StopMatch) {
				if (rematchCount < S_MatchmakingRematchNbMax) 
				{
					isRematch = MM_VoteForRematch();
					rematchCount += 1;
				}			
				if (!isRematch) 
				{
					rematchCount = 0;
					MM_MatchEnd(MasterLogin);
					MM_MatchToLobby();
				}
			}
		} 
		else 
		{
			rematchCount = 0;
			MM_MatchEnd(MasterLogin);
			MM_MatchToLobby();
		}
	}
***

/*
 * GET-SET
 */
Integer get_Mode()
{
	return 1;
}

Integer get_CapturedGoals()
{
	declare captured = 0;
	foreach (goal in KnowGoals)
		if (goal.Gauge.Captured || goal.Gauge.Value == goal.Gauge.Max)
			captured += 1;
	return captured;
}

Ident get_LastGoalId()
{
	return LastGoalCaptured.Id;
}

Integer get_MaxGoals()
{
	if (KnowGoals.count <= 2)
		return KnowGoals.count;
	if (KnowGoals.count >= S_MaxGoals)
		return S_MaxGoals;
	return KnowGoals.count;
}

CSmMapLandmark get_nearestGoalLeft()
{
	declare capturedCount = get_CapturedGoals();
	foreach (i => goal in KnowGoals)
	{
		if (capturedCount + 1 == i && (!goal.Gauge.Captured || goal.Gauge.Value < goal.Gauge.Max))
			return goal;
		if (capturedCount == 0 && i <= 1 && (!goal.Gauge.Captured || goal.Gauge.Value < goal.Gauge.Max))
			return goal;
	}
	foreach (goal in KnowGoals)
	{
		if (!goal.Gauge.Captured || goal.Gauge.Value < goal.Gauge.Max)
			return goal;
	}
	
	return Null;
}

Integer get_MatchWinner()
{
	if (MapScores[1] >= S_MatchMax)
		return 1;
	else if (MapScores[2] >= S_MatchMax)
		return 2;

	if (MapScores[1] >= MapScores[2] + S_MatchGap && MapScores[1] >= S_MatchWin)
		return 1;
	else if (MapScores[2] >= MapScores[1] + S_MatchGap && MapScores[2] >= S_MatchWin)
		return 2;
	
	return 0;
}

/*
 * SLEEP
 */
Void CustomSleep(Integer duration)
{
	declare end = Now + duration;
	while(Now < end) 
	{
		MB_Yield();
		//ManageCommand();
		//ForceClublinkReload();
	}	
}

/*
 * FUNCTIONS
 */

/* ------------------------------------- */
/// Update the Hud3dMarkers.
Void UpdateMarkers(Boolean wu)
{
	// Set the marker above the goal
	UIManager.UIAll.MarkersXML = "";
	
	declare AtkPlayerLogin = Text[Integer];
	for (I, 0, 1)
	{
		if (IDAttackers.existskey(I))
			if (Players.existskey(IDAttackers[I])) AtkPlayerLogin[I] = Players[IDAttackers[I]].Login;
	}
	
	declare ColorPoles = Teams[(3 - CurrAtkClan) - 1].ColorText;
	declare ColorNucleus = TextLib::SubString(Teams[CurrAtkClan - 1].ColorText, 1, 3);
	
	declare NucleusMarker = "";
	
	if (AtkPlayerLogin.count == 2) 
	{
		for (I, 0, 1)
		{
			log(AtkPlayerLogin[I]);
			NucleusMarker ^= """<marker icon="Player{{{I+2}}}" playerlogin="{{{AtkPlayerLogin[I]}}}" box="0 2 0" />""";
		}
	}
	
	declare wuMarkers = """ """;
	if (wu)
	{
		foreach (player in Players)
		{
			declare pvpMode for player = False;
			if (pvpMode)
				wuMarkers ^= """<marker icon="Player1" playerlogin="{{{player.Login}}}" box="0 2 0" />""";
		}
	}
	
	declare PolesMarker = "";
	foreach (i => goal in KnowGoals) 
	{
		if (goal.Gauge.Captured)
			continue;
		
		declare Icon = "";
		declare Name = "";
		if (i == 1) 
			{Icon = "PointA"; Name = "$w$s$oA"; }
		else if (i == 2) 
			{ Icon = "PointB"; Name = "$w$s$oB"; }
		else if (i == 3) 
			{ Icon = "PointC"; Name = "$w$s$oC"; }
		else continue;
		PolesMarker ^= """<marker icon="{{{Icon}}}" pos="{{{goal.Position.X}}} {{{goal.Position.Y + 25}}} {{{goal.Position.Z}}}" />""";
	}
		
	foreach (Player in Players) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		
		if (Player.CurrentClan == CurrAtkClan) {
			UI.MarkersXML = NucleusMarker ^ PolesMarker;
		} else {
			UI.MarkersXML = PolesMarker;
		}
		UI.MarkersXML ^= wuMarkers;
	}
	foreach (Spectator in Spectators) {
		declare UI <=> UIManager.GetUI(Spectator);
		if (UI == Null) continue;
		UI.MarkersXML = PolesMarker ^ NucleusMarker;
	}
}

// ---------------------------------- //
/// Update the score summary header.
Void UpdateHeader() {
	declare CSmPlayer Player1 <=> Null;
	declare CSmPlayer Player2 <=> Null;
	declare HeaderClanScores = Integer[Integer];
	
	HeaderClanScores = [1 => MapScores[1], 2 => MapScores[2]];

	// Find a captain for each clan
	foreach (Player in Players) {
		if (Player.CurrentClan == 1) {
			Player1 <=> Player;
		} else if (Player.CurrentClan == 2) {
			Player2 <=> Player;
		}
	}
	
	UIManager.UIAll.OverlayScoreSummary = True;
	if (Player1 != Null) 
	{
		UIManager.UIAll.ScoreSummary_Player1 = Player1.Id;
		UIManager.UIAll.ScoreSummary_Points1 = ClanScores[1];
		UIManager.UIAll.ScoreSummary_MatchPoints1 = HeaderClanScores[1];
	} 
	else 
	{
		UIManager.UIAll.ScoreSummary_Player1 = NullId;
		UIManager.UIAll.ScoreSummary_Points1 = 0;
		UIManager.UIAll.ScoreSummary_MatchPoints1 = 0;
	}

	if (Player2 != Null) 
	{
		UIManager.UIAll.ScoreSummary_Player2 = Player2.Id;
		UIManager.UIAll.ScoreSummary_Points2 = ClanScores[2];
		UIManager.UIAll.ScoreSummary_MatchPoints2 = HeaderClanScores[2];
	} 
	else 
	{
		UIManager.UIAll.ScoreSummary_Player2 = NullId;
		UIManager.UIAll.ScoreSummary_Points2 = 0;
		UIManager.UIAll.ScoreSummary_MatchPoints2 = 0;
	}
	
	declare netwrite Clan1MapPoints for XmlRpc = 0;
	declare netwrite Clan1MatchPoints for XmlRpc = 0;
	declare netwrite Clan2MapPoints for XmlRpc = 0;
	declare netwrite Clan2MatchPoints for XmlRpc = 0;
	Clan1MapPoints = ClanScores[1];
	Clan1MatchPoints = HeaderClanScores[1];
	Clan2MapPoints = ClanScores[2];
	Clan2MatchPoints = HeaderClanScores[2];
}

Void ChangeSlotOrder()
{
	for (i, 0, 2)
	{
		if (i != E_AtkSelection_Nucleus)
			if (ClansNbPlayers[CurrAtkClan] < 3)
				continue;
		else 
			if (ClansNbPlayers[3 - CurrAtkClan] < 3)
				continue;
			
		declare clan = CurrAtkClan;
		if (i == E_AtkSelection_Nucleus)
			clan = 3 - CurrAtkClan;
		AttackersSlot[clan][i] += 1;
		AttackersSlot[clan][i] += 1;
		
		if (AttackersSlot[clan][i] > S_NbPlayersPerTeamMax) AttackersSlot[clan][i] = 1;
	}
}

Void AddLandmark(Text type, CNod nod)
{
	switch(type)
	{
		case "Goal":
		{
			if (!(nod is CSmMapLandmark))
				assert(False, "Argument 'nod' isn't correct, server asked for CSmMapLandmark not typeof " ^ (nod) ^""); 
		
			declare CSmMapLandmark landmark <=> cast(CSmMapLandmark, nod);
			KnowGoals[landmark.Order] <=> landmark;
		}
		case "Spawn":
		{
			if (!(nod is CSmMapLandmark))
				assert(False, "Argument 'nod' isn't correct, server asked for CSmMapLandmark not typeof " ^ (nod) ^"");
			if (cast(CSmMapLandmark, nod).PlayerSpawn == Null)
				assert(False, "PlayerSpawn don't exist.");
				
			declare CSmMapLandmark landmark <=> cast(CSmMapLandmark, nod);
			TeamSpawns[landmark.Order] <=> landmark;
		}
		case "Gauge":
		{
			if (!(nod is CSmMapGauge))
				assert(False, "Argument 'nod' isn't correct, server asked for CSmMapGauge not typeof " ^ (nod) ^"");
				
			declare CSmMapGauge gauge <=> cast(CSmMapGauge, nod);
			GaugeLandmarks.add(gauge);
		}
		case "Base":
		{
			if (!(nod is CSmMapBase))
				assert(False, "Argument 'nod' isn't correct, server asked for CSmMapBase not typeof " ^ (nod) ^"");
				
			declare CSmMapBase base <=> cast(CSmMapBase, nod);
			BaseLandmarks.add(base);
		}
	}
}

Void ResetLandmarks()
{
	KnowGoals.clear();
	TeamSpawns.clear();
	GaugeLandmarks.clear();
	BaseLandmarks.clear();
	
	foreach (goal in MapLandmarks_Gauge)
	{
		if (goal.Tag == "CGoal" && goal.Order >= 0)
			AddLandmark("Goal", goal);
	}
	foreach (spawn in MapLandmarks_PlayerSpawn)
	{
		if (spawn.Tag == "CSpawn" && spawn.Order > 0)
			AddLandmark("Spawn", spawn);
	}
	foreach (other in MapLandmarks)
	{
		if (other.Tag != "CGoal" && other.Tag != "CSpawn")
		{
			if (other.Gauge != Null)
				AddLandmark("Gauge", other.Gauge);
			if (other.Base != Null)
				AddLandmark("Base", other.Base);
		}
	}
	
	// Legacy phase
	if (KnowGoals.count <= 0)
	{
		foreach (goal in MapLandmarks_Gauge)
		{
			if (goal.Tag == "Goal A")
				KnowGoals[1] <=> goal;
			if (goal.Tag == "Goal B")
				KnowGoals[2] <=> goal;
			if (goal.Tag == "Goal C")
				KnowGoals[3] <=> goal;
		}
	}
	if (TeamSpawns.count <= 0)
	{
		foreach (spawn in MapLandmarks_PlayerSpawn)
		{
			if (spawn.Tag == "SpawnAttack")
				TeamSpawns[2] <=> spawn;
			if (spawn.Tag == "SpawnDefense")
				TeamSpawns[1] <=> spawn;
		}
	}
	
	if (KnowGoals.count <= 0 || TeamSpawns.count <= 0)
	{
		MatchEndRequested = True;
		MB_StopMap = True;
		UIManager.UIAll.BigMessage = "Map couldn't be used!";
		UIManager.UIAll.SendChat("Invalid Map");
	}
	
}

Void PrepareField(Integer E_PreparationField)
{
	switch (E_PreparationField)
	{
		case E_Preparation_Warmup:
		{
			// Spawns de couleurs, et couleur des goals dépendantes
			// 1 -> atk
			// 2 -> def
			// 3 -> neutre
			foreach (i => spawn in TeamSpawns)
				{ spawn.Base.IsActive = True; spawn.Base.Clan = i; } 
			foreach (i => goal in KnowGoals)
				{ goal.Base.IsActive = True; goal.Base.Clan = i; goal.Gauge.Clan = i;
				  goal.Gauge.Value = goal.Gauge.Max; goal.Gauge.Captured = True; } 
				
			foreach (base in BaseLandmarks)
			{
				base.IsActive = False;
				base.Clan = 0;
			}
		}
		case E_Preparation_WinningSequence:
		{
			foreach (landmark in MapLandmarks)
			{
				if (landmark.Base != Null)
				{
					declare base <=> landmark.Base;
					
					base.IsActive = True;
					base.Clan = Round_WinningClan;
				}
				if (landmark.Gauge != Null)
				{
					declare gauge <=> landmark.Gauge;
					
					gauge.Value = gauge.Max;
					gauge.Captured = True;
					gauge.Clan = Round_WinningClan;
				}
			}
		}
		case E_Preparation_IntroOutro:
		{
			// On enlève toute les couleurs
			foreach (spawn in TeamSpawns)
				{ spawn.Base.IsActive = False; spawn.Base.Clan = 0; } 
			foreach (goal in KnowGoals)
				{ goal.Base.IsActive = False; goal.Base.Clan = 0; goal.Gauge.Clan = 0;
				  goal.Gauge.Value = 0; goal.Gauge.Captured = False; } 
				
			foreach (base in BaseLandmarks)
			{
				base.IsActive = False;
				base.Clan = 0;
			}
		}
		case E_Preparation_Playing:
		{
			// Spawns de couleurs, et couleur des goals dépendantes
			// 1 -> atk
			// 2 -> def
			// 3 -> neutre
			foreach (spawn in TeamSpawns)
			{ 
				spawn.Base.IsActive = True;
				if (spawn.Order == CurrAtkClan)
					spawn.Base.Clan = 3 - CurrAtkClan;
				else spawn.Base.Clan = CurrAtkClan;
			} 
			foreach (goal in KnowGoals)
			{ 
				goal.Base.IsActive = True;
				goal.Base.Clan = 3 - CurrAtkClan;
				goal.Gauge.Clan = 3 - CurrAtkClan;
				goal.Gauge.Value = goal.Gauge.Max; 
				goal.Gauge.Captured = False; 
			} 
				
			foreach (base in BaseLandmarks)
			{
				base.IsActive = False;
				base.Clan = 0;
			}			
		}
	}
}

Void PlaySound(CUIConfig::EUISound _Sound, Integer _Variant) {
  UIManager.UIAll.SendNotice("", CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default, _Sound, _Variant);
}

CNod GetOriginal(CNod nod)
{
	if (nod is CSmMapLandmark)
	{
		declare landmark <=> cast(CSmMapLandmark, nod);
		foreach (lm in MapLandmarks)
		{
			if (landmark.Tag == lm.Tag
				&& landmark.Order == lm.Order
				&& landmark.Base == lm.Base)
			return lm;
		}
	}
	return Null;
}

CSmMapLandmark CaptureGoal(CSmMapLandmark landmark)
{
	declare lastCaptureTime for This = -1;
	if (lastCaptureTime == Now)
		return landmark;
		
	GotCaptured = True;
		
	lastCaptureTime = Now;

	landmark.Gauge.Clan = CurrAtkClan;
	landmark.Base.Clan = CurrAtkClan;
	landmark.Gauge.Speed = 0;
	
	//if (landmark.Gauge.Value != landmark.Gauge.Max)
		landmark.Gauge.Value = landmark.Gauge.Max;
		
	if (get_CapturedGoals() < get_MaxGoals())
	{
		PlaySound(CUIConfig::EUISound::Capture, 0);
		Message::SendBigMessage(TextLib::Compose("Pole captured by $<%1$> !", Teams[CurrAtkClan - 1].ColorizedName), 3500, 10);
	}
	else
	{
		PlaySound(CUIConfig::EUISound::Capture, 1);
		Message::SendBigMessage(TextLib::Compose("$<%1$> captured the last pole.", Teams[CurrAtkClan - 1].ColorizedName), 3500, 10);
		
		Round_WinningClan = CurrAtkClan;
		MB_StopTurn = True;
	}
			
	EndTime += (S_BonusTime*1000);
	LastGoalCaptured <=> (GetOriginal(landmark) as CSmMapLandmark);
		
	landmark.Base.Clan = landmark.Gauge.Clan;
	
	//if (!landmark.Gauge.Captured)
		landmark.Gauge.Captured = True;
		
	GoalCanBeCaptured = False;
	PoleTime = Now + (S_DelayCapture * 1000);
	UIManager.UIAll.BigMessage = "";
	UIManager.UIAll.CountdownEndTime = PoleTime;
	
	return LastGoalCaptured;
}

Void ManageEvents()
{
	foreach (Event in PendingEvents) {
		log(Event.Type);
		if (Event.Type == CSmModeEvent::EType::OnHit) {
			if (Event.Shooter != Null && Event.Victim != Null && Event.Victim == Event.Shooter) {
				Discard(Event);
			} else if (Event.Victim != Null) {
				declare shooterPvpMode = False;
				{
					declare pvpMode for Event.Shooter = False;
					shooterPvpMode = pvpMode;
				}
			
				declare pvpMode for Event.Victim = False;
				Event.Damage = 100;
				if (pvpMode && shooterPvpMode)
				{
					
					PassOn(Event);
				}
				else
				{
					if (!pvpMode)
						Event.Victim.Armor = Event.Victim.ArmorMax;
					Discard(Event);
				}
			} else {
				PassOn(Event);
			}
		} else if (Event.Type == CSmModeEvent::EType::OnArmorEmpty) {
			if (Event.Shooter != Null && Event.Victim != Null) {
				declare shooterPvpMode = False;
				{
					declare pvpMode for Event.Shooter = False;
					shooterPvpMode = pvpMode;
				}
				declare pvpMode for Event.Victim = False;
				
				if (pvpMode && shooterPvpMode)
				{
					
					PassOn(Event);
				}
				else
				{
					if (!pvpMode)
						Event.Victim.Armor = Event.Victim.ArmorMax;
					Discard(Event);
				}
			} else {
				PassOn(Event);
			}
		} else if (Event.Type == CSmModeEvent::EType::OnPlayerTouchesObject) {
			Discard(Event);
		} else if (Event.Type == CSmModeEvent::EType::OnActionEvent)
		{
			log(Event.ActionInput);
			if (Event.ActionInput == CSmModeEvent::EActionInput::Consumable1)
			{
				declare pvpMode for Event.Player = False;
				pvpMode = !pvpMode;
			}
		} else {
			PassOn(Event);
		}
	}
	
	foreach (player in Players)
	{
		declare pvpMode for player = False;
		player.HasShield = pvpMode;
		player.IsHighlighted = pvpMode;
		
		Message::SendStatusMessage(player, "PVPMODE: " ^ pvpMode, 1, 1);
	}
}

Void WarmUp(Boolean pause)
{
	WarmUp_Set = False;

	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;

	// Begin Warmup, Clean to prevent commun bugs, and refill it
	WarmUp2::Begin();
	WarmUp2::Clean();
	
	UpdateMarkers(True);
	
	WarmUp2::SetAllSlotsIcons("Clan1", "file://Media/Manialinks/ShootMania/Common/Rocket.dds");
	WarmUp2::SetAllSlotsIcons("Clan2", "file://Media/Manialinks/ShootMania/Common/Rocket.dds");

	StartTime = Now;
	EndTime = -1;
	
	// Init the players
	foreach (Player in Players) {
    	SetPlayerClan(Player, MM_GetRequestedClan(Player));
    	if (Player.CurrentClan == 1) 
			WarmUp2::SetPlayerGroup(Player, "Clan1");
    	else if (Player.CurrentClan == 2) 
			WarmUp2::SetPlayerGroup(Player, "Clan2");
  	}

	declare Integer prevAskedMode;
	declare Integer prevWarmUpDuration;
	
	+++StartWarmUp+++
	
	UIManager.UIAll.BigMessage = "";
	UIManager.UIAll.StatusMessage = "";
	
	while (!WarmUp2::Stop()) 
	{
		MB_Yield();
		WarmUp2::Loop();	
		ManageEvents();
		
		WarmUp2::Fill();
		
		UpdateMarkers(True);
		
		if (!pause)
			UIManager.UIAll.BigMessage = TextLib::Compose("$f90%1", _("Warm-up"));
		else
			UIManager.UIAll.BigMessage = TextLib::Compose("$f90%1", _("Pause"));
		
		if (PlayersNbTotal <= 0) continue;
		
		if (get_Mode() != prevAskedMode || prevWarmUpDuration != S_WarmUpDuration) 
		{
      		prevWarmUpDuration = S_WarmUpDuration;
      
			declare LongTimer = S_WarmUpDuration*1000;
			declare ShortTimer = 5000;
			if (LongTimer <= 0) 
				{ LongTimer = 0; ShortTimer = 0; }
      
      		if (get_Mode() == E_Mode_Classic) 
			{
				WarmUp2::SetGroupTimers("Clan1", [ShortTimer => [-2, S_NbPlayersPerTeamMax], LongTimer => [2, S_NbPlayersPerTeamMax]]);
				WarmUp2::SetGroupTimers("Clan2", [ShortTimer => [-2, S_NbPlayersPerTeamMax], LongTimer => [2, S_NbPlayersPerTeamMax]]);
      		} 
			else 
			{
				WarmUp2::SetGroupTimers("Clan1", [ShortTimer => [-1, 1], LongTimer => [1, 1]]);
				WarmUp2::SetGroupTimers("Clan2", [ShortTimer => [-1, 1], LongTimer => [1, 1]]);
      		}
		}
		
		foreach (Player in Players)
		{
			if (Player.CurrentClan != MM_GetRequestedClan(Player)) {
				UnspawnPlayer(Player);
				SetPlayerClan(Player, MM_GetRequestedClan(Player));
				if (Player.CurrentClan == 1) 
					WarmUp2::SetPlayerGroup(Player, "Clan1");
				else if (Player.CurrentClan == 2)
				 	WarmUp2::SetPlayerGroup(Player, "Clan2");
      		}

			// Spawn them all
			if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) continue;
			
			declare lastSpawn for Player = 0;
			if (lastSpawn > 1)
				lastSpawn = 0;
			
			SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, 4);
			SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, 1);
			SetPlayerAmmoMax(Player, CSmMode::EWeapon::Nucleus, 1);
    
			Player.ArmorMax = 300;
			Player.AmmoGain = 1.;
			Player.StaminaMax = 1.;
			Player.StaminaGain = 1.;
			SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, True);
			SM::SpawnPlayer(Player, MM_GetRequestedClan(Player), Player.ArmorMax, TeamSpawns[lastSpawn+1].PlayerSpawn, Now);
			Player.IsHighlighted = True;
			
			lastSpawn += 1;
		}
	}
	
	WarmUp2::End();
	UIManager.UIAll.BigMessage = "";
	PrepareField(E_Preparation_IntroOutro);
	
	MB_Sleep(250);
	SM::UnspawnAllPlayers();
	MB_Sleep(250);
	
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
	
	MB_Sleep(1000);
}

Void ChooseAttackers()
{
	declare Clan = "Clan" ^ CurrAtkClan;
	declare SlotNb = WarmUp2::GetSlotsNb(Clan);
	declare laserTurn = 0;
	declare Ident[] existingAttackers;
	
	IDAttackers[3] = Ident;
	
	declare noEnoughtPlayer = 0;
	for (i, 1, 2)
		if (ClansNbPlayers[i] <= 1)
			noEnoughtPlayer += 1;
	if (noEnoughtPlayer >= 1)
	{
		UIManager.UIAll.SendChat("Can't start the match! (no enought players)");
		UIManager.UIAll.SendChat("(2vs2 min) Blue " ^ ClansNbPlayers[1] ^ " - Red " ^ ClansNbPlayers[2] ^ " players");
		
		Round_WinningClan = 0;
		MB_StopTurn = True;
		WarmUp_Set = True;
	}
	
	WarmUp2::Fill();
	
	// Attackers
	while (laserTurn < 3) {
		declare AS = 0;
		
		WarmUp2::Fill();
		for (I, 0, 1)
		{
			if (laserTurn == 1)
			{
				laserTurn = 2;
				AttackersSlot[CurrAtkClan][E_AtkSelection_Laser] = AttackersSlot[CurrAtkClan][E_AtkSelection_Rocket];
			}
		
			if (AttackersSlot[CurrAtkClan][I] > S_NbPlayersPerTeamMax)
				AttackersSlot[CurrAtkClan][I] = 1;
		
			declare PlayerId = WarmUp2::GetSlot(Clan, AttackersSlot[CurrAtkClan][I]);
			if (PlayerId != NullId && Players.existskey(PlayerId) && !existingAttackers.exists(PlayerId)) {
				if (laserTurn == 0)
					laserTurn = 1;
				else laserTurn = 3;
				
				UIManager.UIAll.SendChat("" ^ laserTurn);
				
				IDAttackers[1 - I] = PlayerId;
				
				existingAttackers.add(PlayerId);
				continue;
			}
		
			AttackersSlot[CurrAtkClan][I] += 1;
			AS += 1;
			if (AS >= SlotNb) continue;
		}
		yield;
	}
	
	Clan = "Clan" ^ 3 - CurrAtkClan;
	SlotNb = WarmUp2::GetSlotsNb(Clan);
	
	// Nucleus Defender
	declare AS = 0;
	while(True)
	{
		if (AttackersSlot[3 - CurrAtkClan][E_AtkSelection_Rocket] > S_NbPlayersPerTeamMax)
			AttackersSlot[3 - CurrAtkClan][E_AtkSelection_Rocket] = 1;
	
		declare PlayerId = WarmUp2::GetSlot(Clan, AttackersSlot[3 - CurrAtkClan][E_AtkSelection_Rocket]);
		if (PlayerId != NullId && Players.existskey(PlayerId)) {
			IDAttackers[E_AtkSelection_Nucleus] = PlayerId;
			
			UIManager.UIAll.SendChat("--");
			
			existingAttackers.add(PlayerId);
			break;
		}

		AttackersSlot[3 - CurrAtkClan][E_AtkSelection_Rocket] += 1;
		AS += 1;
		if (AS >= SlotNb) break;
	}
}

Void _SpawnPlayer(Integer team, Integer grade, CSmPlayer player)
{
	SetPlayerAmmoMax(player, CSmMode::EWeapon::Rocket, 4);
	SetPlayerAmmoMax(player, CSmMode::EWeapon::Laser, 1);
	SetPlayerAmmoMax(player, CSmMode::EWeapon::Nucleus, 1);
    
	player.ArmorMax = 100;
	player.AmmoGain = 1.;
	player.StaminaMax = 1.;
	player.StaminaGain = 1.;

	if (team == CurrAtkClan)
	{
		// Rocket Atk
		if (grade == 0)
		{
			player.ArmorMax = ((DefenderCount) * 100);
			SetPlayerWeapon(player, CSmMode::EWeapon::Rocket, False);
			
			SM::SpawnPlayer(player, CurrAtkClan, player.ArmorMax, TeamSpawns[2].PlayerSpawn, Now);
		}
		if (grade == 1)
		{
			SetPlayerWeapon(player, CSmMode::EWeapon::Laser, False);
			
			player.ArmorMax = ((DefenderCount) * 100);
			SM::SpawnPlayer(player, CurrAtkClan, player.ArmorMax, TeamSpawns[2].PlayerSpawn, Now);
		}
	}
	else
	{
		if (grade == 2)
		{
			SetPlayerWeapon(player, CSmMode::EWeapon::Nucleus, True);
			
			SM::SpawnPlayer(player, 3 - CurrAtkClan, player.ArmorMax, TeamSpawns[1].PlayerSpawn, Now);
		}
		else
		{
			SetPlayerWeapon(player, CSmMode::EWeapon::Rocket, True);
			
			SM::SpawnPlayer(player, 3 - CurrAtkClan, player.ArmorMax, TeamSpawns[1].PlayerSpawn, Now);
		}
	}
}

Void SpawnThemAll()
{
	foreach (player in Players)
	{
		declare grade = -1;
		if (player.Id == IDAttackers[E_AtkSelection_Rocket])
			grade = 0;
		if (player.Id == IDAttackers[E_AtkSelection_Laser])
			grade = 1;
		if (player.Id == IDAttackers[E_AtkSelection_Nucleus])
			grade = 2;
		_SpawnPlayer(player.CurrentClan, grade, player);
	}
}

Void UnspawnLoosers()
{
	if (Round_WinningClan == CurrAtkClan)
	{
		foreach (player in Players)
			if (player.CurrentClan != CurrAtkClan)
				UnspawnPlayer(player);
	}
	else
	{
		foreach (player in Players)
			if (player.CurrentClan == CurrAtkClan)
				UnspawnPlayer(player);
	}
}

Void StartMatch()
{
	CanStartNewMatch = False;
	
	SM::UnspawnAllPlayers();
	MapScores = [1 => 0, 2 => 0];
	
	UpdateHeader();
}

Void View(Ident Id) 
{
	foreach (Player in Players) 
	{
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		UIManager.UIAll.SpectatorForcedTarget = Id;
		UIManager.UIAll.SpectatorCamAutoRadius = 100.;
	}
	foreach (S in Spectators) 
	{
		declare UI <=> UIManager.GetUI(S);
		if (UI == Null) continue;
		UIManager.UIAll.SpectatorForcedTarget = Id;
		UIManager.UIAll.SpectatorCamAutoRadius = 100.;
	}
}

Text Layer_CaptureGauge()
{
	declare HVC = """ halign="center" valign="center" """;
	declare HVRB = """ halign="right" valign="bottom" """;
	return """
	<frame id="mainFrame" posn="0 -37.5" scale="0.5">
		<label id="labelProgression" {{{HVRB}}} posn="45 2.5" textsize="14" text="$s$t100" style="TextButtonBig"  />
		<label id="labelModulo" {{{HVRB}}} posn="55 4" textsize="14" scale="0.625" text="$s%" style="TextButtonBig"  />
		<gauge id="captureGauge" {{{HVC}}} sizen="120 10" style="EnergyBar" drawbg="1" drawblockbg="1" />
	</frame>
	
	<script><!--
		#Include "MathLib" as MathLib
		#Include "TextLib" as TextLib
	
		***Start***
		***
			declare MainFrame = cast(CMlFrame, Page.GetFirstChild("mainFrame"));
			declare CaptureGauge = cast(CMlGauge, Page.GetFirstChild("captureGauge"));
			declare LabelProgression = cast(CMlLabel, Page.GetFirstChild("labelProgression"));
			declare LabelModulo = cast(CMlLabel, Page.GetFirstChild("labelModulo"));
		***
	
		***Update***
		***
			if (GUIPlayer != Null)
			{
				if (GUIPlayer.CapturedLandmark != Null)
				{
					declare landmark <=> GUIPlayer.CapturedLandmark;
					CaptureGauge.SetRatio(Lerp(CaptureGauge.Ratio, landmark.Gauge.ValueReal, 0.25));
					CaptureGauge.Clan = landmark.Gauge.Clan;
					
					if (landmark.Gauge.Speed < 0)
					{
						LabelModulo.SetText("$ss");
						
						declare value = "" ^ ((landmark.Gauge.Value/landmark.Gauge.Speed)/-1000) + 1;
						LabelProgression.SetText("$s" ^ TextLib::SubText(value, 0, 2));
					}
					else
					{
						LabelModulo.SetText("$s%");
						LabelProgression.SetText("$s" ^ MathLib::NearestInteger(landmark.Gauge.ValueReal*100));
					}
					
					
					MainFrame.Show();
				}
				else MainFrame.Hide();
			}
			else MainFrame.Hide();
		***
		
		Real Lerp(Real a, Real b, Real t)
		{
			return a*(1-t) + b*t;
		}
	
		main()
		{
			+++Start+++
			while(True)
			{
				+++Update+++
				yield;
			}
		}
	--></script>
	""";
}