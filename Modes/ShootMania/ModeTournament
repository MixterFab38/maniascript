///////////////////////////////////////////////////////
////  ********************----- Code parts from me ////
////  ***--------------- Code parts from ModeSport ////
////  **------------------- Code parts from others ////
///////////////////////////////////////////////////////

///////////////////////////////////////////////////////
/* Champions, Second rewrites XDDDD
From Guerro. */
///////////////////////////////////////////////////////

#Extends "Modes/ShootMania/ModeMatchmaking.Script.txt"

#Include "Libs/Nadeo/Victory.Script.txt" as Victory
#Include "Libs/Nadeo/ShootMania/WarmUp2.Script.txt" as WarmUp2
#Include "Libs/Nadeo/Json.Script.txt" as Json
#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map
#Include "Libs/Nadeo/ShootMania/Toss.Script.txt" as Toss

#Const	ModeVersion				"2015-09-20"
#Const	ModeScriptName			"ModeGuerro.Script.txt"

// // // // // // // // // // // // 
//// ---- Settings ---- ////
#Setting S_Mode 1 as _("1")
#Setting S_TimeLimit 50 as _("Attack time limit")
#Setting S_TimePole 20 as _("Capture time limit")
#Setting S_TimeCapture 1.5 as _("Capture duration by pole")
#Setting S_WarmUpDuration 90 as _("Warmup duration (0: disabled)")
#Setting S_MatchPoints 2 as _("Number of maps to win a match")
#Setting S_Turn 9 as _("Default map points limit")
#Setting S_TurnGap 2 as _("Minimum points gap to win a map")
#Setting S_TurnMax 15 as _("Decider map points limit")
#Setting S_QuickMode False as _("Less time between rounds")
#Setting S_NbPlayersPerTeamMax 4 as _("Numbers of players per team max")
#Setting S_UseToss False as _("Use toss system")
#Setting S_Practice				False	as _("Play in practice mode")
#Setting S_PracticeRoundLimit	3		as _("Number of attack turns by player in practice mode")
// // // // // // // // // // // // 

// // // // // // // // // // // // 
//// ---- Commands ---- ////
#Command Command_MatchPointsClan1			(Integer)	as _("Match points for clan 1")
#Command Command_MatchPointsClan2			(Integer)	as _("Match points for clan 2")
#Command Command_CurrentMapPointsClan1		(Integer)	as _("Current map points for clan 1")
#Command Command_CurrentMapPointsClan2		(Integer)	as _("Current map points for clan 2")
#Command Command_PreviousMapsPointsClan1	(Integer)	as _("Previous maps points for clan 1")
#Command Command_PreviousMapsPointsClan2	(Integer)	as _("Previous maps points for clan 2")
#Command Command_ForceFirstAtkClan			(Integer)	as _("Force first attacking clan on the map (1: Blue, 2: Red)")
#Command Command_ForceG_TossWinner			(Integer)	as _("Force toss winner (1: Blue, 2: Red)")
#Command Command_ForceWarmUp				(Boolean)	as _("Set pause")
#Command Command_ForceClublinkReload		(Boolean)	as _("Force clublink reload")
// // // // // // // // // // // // 

// // // // // // // // // // // // 
//// ---- Const ---- ////
#Const C_SpawnAtk "SpawnAttack"
#Const C_SpawnDef "SpawnDefense"

#Const C_DefElimination 0
#Const C_AtkElimination 1
#Const C_UltimateElimination 2
#Const C_GoalCaptured 3
#Const C_GoalsCaptured 4
#Const C_OverTime 5
#Const C_NoGoals 404

#Const C_GEs 1
#Const C_Champions 2

#Const C_PresentationTime 1000

#Const C_WURocketAmmoMax			4	///< Rocket ammo max
#Const C_WURocketAmmoGain			1.	///< Rocket ammo regen speed
#Const C_WULaserAmmoMax				1	///< Laser ammo max
#Const C_WULaserAmmoGain			1.	///< Laser ammo regen speed
#Const C_WUNucleusAmmoMax			1	///< Nucleus ammo max
#Const C_WUNucleusAmmoGain			1.3	///< Nucleus ammo regen speed
#Const C_DefStaminaMaxMultiplier	0.7 ///< Stamina amount multiplier for the defense
#Const C_AtkStaminaMaxMultiplier	1.	///< Stamina amount multiplier for the attack


#Const C_AtkRocketAmmoMax	4	///< Atk Rocket ammo max
#Const C_AtkRocketAmmoGain	1.	///< Atk Rocket ammo gain
#Const C_AtkLaserAmmoMax	1	///< Atk Laser ammo max
#Const C_AtkLaserAmmoGain	0.8	///< Atk Laser ammo gain
#Const C_AtkNucleusAmmoMax	1	///< Atk Nucleus ammo max
#Const C_AtkNucleusAmmoGain	1.	///< Atk Nucleus ammo gain

#Const C_DefRocketAmmoMax	4	///< Def Rocket ammo max
#Const C_DefRocketAmmoGain	1.	///< Def Rocket ammo gain
#Const C_DefLaserAmmoMax	1	///< Def Laser ammo max
#Const C_DefLaserAmmoGain	1.	///< Def Laser ammo gain
#Const C_DefNucleusAmmoMax	1	///< Def Nucleus ammo max
#Const C_DefNucleusAmmoGain	1.	///< Def Nucleus ammo gain



#Const C_WeaponLaser	1
#Const C_WeaponRocket	2
#Const C_WeaponNucleus	3
// // // // // // // // // // // // 

//// ---- Globales ---- ////
declare Boolean G_OldMap;
declare Boolean MT_QuickStop;
declare Integer[Integer][Integer] G_AtkSlot;
declare Integer[Integer] G_MapScores;
declare Integer[Integer] G_MatchPoints;
declare Integer	G_LastSpecUpdate;				///< Last time the spectators were updated
declare Integer G_Reason;
declare Integer G_Gameplay;
declare Integer G_FirstAtk;
declare Integer G_AtkClan;
declare Integer G_DefClan;
declare Integer G_WinningTurn;
declare Text[Integer] G_NextAtkName;
declare Text	G_LongestRailName;				///< Name of the player with the longest Laser hit
declare Text G_ReasonMessage1;
declare Text G_ReasonMessage2;
declare Ident[Integer] G_Attackers; // Ok, this variable will be only used one time.
declare Vec3	G_MapSpecCamDirection;			///< Spectator camera orientation
declare Real	G_LongestRailDistance;			///< Distance of the longest Laser hit

// From Commands ( And ModeSport too xd )
declare Integer G_Override_FirstAtkClan;
declare Integer G_Override_G_TossWinner;
declare Boolean G_Override_NeedWarmUp;
declare Boolean G_Override_ForceClublinkReload;

declare Integer G_TiePoints;
declare Integer G_TossWinner;
declare Integer G_VoteClanNb;

declare Boolean G_Practice;
declare Integer AtkSpawned;
declare Integer DefSpawned;
// // // // // // // // // // // // 

// END.......... /*    ----------------     */
***InitServer***
***
log("========--------------------========");
log("==----------W e l c o me ---------==");
log("Loaded 'ExtendFile' >"^ModeVersion^" . "^ModeScriptName);
log("Loaded 'Gamemode' >"^Version^" . "^ScriptName);
log("==---------S e t t i n g s -------==");
log("Loaded > S_LoosePoints = ");
log("========--------------------========");  
***

***StartServer***
***
declare WinnerMatchClan = -1;		///< Winner Clan for a match

MB_UseSectionRound		= True;
MB_UseSectionTurn = True;
G_AtkClan = MathLib::Rand(1,2);
G_DefClan = 3-G_AtkClan;
UseClans = True;

G_NextAtkName = [1 => "ERROR", 2 => "ERROR"];
G_AtkSlot[1] = [1 => 1, 2 => 1];
G_AtkSlot[2] = [1 => 2, 2 => 2];

G_WinningTurn = 0;
G_FirstAtk = -1;

G_Attackers = [1 => Ident, 2 => Ident];

G_ReasonMessage1 = "";
G_ReasonMessage2 = "";
G_Practice = False;

WarmUp2::Load();
WarmUp2::CreateGroup("Clan1", S_NbPlayersPerTeamMax);
WarmUp2::CreateGroup("Clan2", S_NbPlayersPerTeamMax);
WarmUp2::DisplayClanSelection(True);
***

***StartMatch***
***
Victory::MatchBegin();
G_Practice = S_Practice;
G_MapScores = [1 => 0, 2 => 0];
G_Override_FirstAtkClan = -1;
G_Override_G_TossWinner = -1;
G_Override_NeedWarmUp = False;
WinnerMatchClan = -1;
G_TossWinner = -1;
***

***StartMap***
***
if (GetMode() == 1) G_Gameplay = C_GEs;
else G_Gameplay = C_Champions;
UpdateHeader();

declare Goals = CSmMapLandmark[];

declare Spawns = [1 => CSmMapPlayerSpawn, 2 => CSmMapPlayerSpawn];

+++InitVarMap+++

foreach (Landmark in MapLandmarks_Gauge) {
	if (Landmark.Tag == C_SpawnAtk) {
	Spawns[1] = Landmark.PlayerSpawn;
	} else if (Landmark.Tag == C_SpawnDef) {
	Spawns[2] = Landmark.PlayerSpawn;
	} 
	
	if (Landmark.Tag == "Goal A" ||
	Landmark.Tag == "Goal B" || Landmark.Tag == "Goal C") G_OldMap = True;
	
	else {
		if (Landmark.Tag == "Goal") Goals.add(Landmark);
	}
	
	if (G_OldMap) {
	if (Landmark.Tag == "Goal A" ||
	Landmark.Tag == "Goal B" || Landmark.Tag == "Goal C") Goals.add(Landmark);
	}
}

log(Goals.count);


***



***InitStartServerRound***
***
log(Now^"> Rounds mode actived");
***

***StartRound***
***
Victory::RoundBegin();

if (Players.count > 2 && G_Practice) G_Practice = True;
else if (Players.count <= 2 || !G_Practice) G_Practice = False; 

for (Clan, 1, 2)
ClanScores[Clan] = 0;

WarmUp2();
***

***StartTurn***
***
foreach (Player in AllPlayers) {
	SetPlayerClan(Player, MM_GetRequestedClan(Player));
	
	// Remove players not allowed by matchmaking
	if (MM_IsMatchServer() && !MM_PlayerIsValid(Player)) {
		WarmUp2::UnsetPlayerGroup(Player);
	} else {
		if (Player.CurrentClan == 1) WarmUp2::SetPlayerGroup(Player, "Clan1");
		else if (Player.CurrentClan == 2) WarmUp2::SetPlayerGroup(Player, "Clan2");
	}
}

if (S_UseToss) { DoToss(); }

G_DefClan = DefClan();

// ---------------------------------- //
// init variables
	+++InitVarTurn+++
	
// ---------------------------------- //
// Stop the map is there are no goals;
if (Goals.count <= 0) { MT_StopRound(1); }

MT_Sleep(500);

PoleTime = (S_TimeLimit) * 1000;

// ---------------------------------- //
// Play team presentation
if (MB_SectionTurnNb <= 1) {
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedHidden;
	MT_Presentation(GetSleep()*C_PresentationTime);
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
} else {
	G_AtkClan = DefClan();
	G_DefClan = DefClan();
}

log(G_DefClan^" > "^G_AtkClan);

StartTime = -1;
EndTime = -1;

WarmUp2::Fill();

UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;

MT_Sleep(200*GetSleep());

if (GetMode() == 1) G_Gameplay = C_GEs;
else G_Gameplay = C_Champions;

AtkSlot(G_Gameplay);
G_AtkSlot[G_AtkClan][1] += 1;

log(G_NextAtkName[1]^" < > "^G_NextAtkName[2]);

declare Message1 = "";
declare Message2 = "";
declare TeamAtkName = "";
declare TeamDefName = "";
TeamAtkName = Teams[G_AtkClan - 1].ColorizedName;
TeamDefName = Teams[G_DefClan - 1].ColorizedName;
UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::PhaseChange;
UIManager.UIAll.BigMessageSoundVariant = 0;

for (AtkCount, 1, 2)
if (G_Gameplay == C_GEs) Message1 = TextLib::Compose(_("$<%1$> is attacking!"), G_NextAtkName[1]);
else Message1 = TextLib::Compose(_("$s$<%1$> will start in attack."), Teams[G_AtkClan-1].ColorizedName);
Message2 = TextLib::Compose(
	_("$<%1$> attack - defense $<%2$>"), 
	TeamAtkName, 
	TeamDefName
);

UIManager.UIAll.BigMessage = Message1;
UIManager.UIAll.StatusMessage = Message2;

MT_Sleep(1000*GetSleep());

UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing ;

MT_Sleep(100*GetSleep());

SpawnPlayers();

foreach (Goal in Goals) {
	Goal.Gauge.Max = PoleTime;
	Goal.Gauge.Value = Goal.Gauge.Max;
	Goal.Gauge.Clan = G_DefClan;
	Goal.Gauge.Speed = -1;
	InitBasesColor();
}

UIManager.UIAll.CountdownEndTime = PoleTime + Now;

StartTime = Now;
EndTime = Now + ((S_TimeLimit + S_TimePole)*1000);

MT_Sleep(400*GetSleep());

UIManager.UIAll.BigMessage = "";
UIManager.UIAll.StatusMessage = "";

MT_Sleep(100);
***

***PlayLoop***
***
while (!MB_StopServer
	&& !MatchEndRequested
	&& !MB_StopMatch
	&& !MM_RestartMatchmaking
	&& !MB_StopMap
	&& !MB_StopSubmatch
	&& !MB_StopRound
	&& !MB_StopTurn
	&& !G_Override_NeedWarmUp
) {
    MB_Yield();
	+++TournamentLoop+++
}
***

***TournamentLoop***
***
	foreach (Event in PendingEvents) {
		if (Event.Type == CSmModeEvent::EType::OnCommand) {
		
			}
		}
						

foreach (Event, PendingEvents) {
	// ---------------------------------- //
	// On armor empty
	if (Event.Type == CSmModeEvent::EType::OnArmorEmpty) {
---OnArmorEmpty---
		XmlRpc::OnArmorEmpty(Event);
		
	} 
	// ---------------------------------- //
	// On hit
	else if (Event.Type == CSmModeEvent::EType::OnHit ) {
	if (Event.Shooter != Null && Event.Victim != Null) {
 if (Event.Victim.CurrentClan == Event.Shooter.CurrentClan) { ---Event_OnHitAlly--- }
 if (Event.Victim.CurrentClan != Event.Shooter.CurrentClan) { ---Event_OnHit--- }
}

//UpdateHitrate(Event.Shooter);
			XmlRpc::OnHit(Event);
		
	
	}
	
		// ---------------------------------- //
	// On Miss
	else if (Event.Type == CSmModeEvent::EType::OnNearMiss ) {
	if (Event.Shooter != Null && Event.Victim != Null)
---OnMiss---

//UpdateHitrate(Event.Shooter);
			XmlRpc::OnHit(Event);
		
	
	} 
	
	// ---------------------------------- //
	// On Miss
	else if (Event.Type == CSmModeEvent::EType::OnCapture ) {
	if (Event.Landmark != Null)
---Event_OnCapture---
		
	
	} 
	
			// ---------------------------------- //
	// On Deny
	else if (Event.Type == CSmModeEvent::EType::OnShotDeny ) {
	if (Event.Shooter != Null && Event.Victim != Null)
---OnDeny---

//UpdateHitrate(Event.Shooter);
			XmlRpc::OnHit(Event);
		
	
	}
	
				// ---------------------------------- //
	// On Deny
	else if (Event.Type == CSmModeEvent::EType::OnFallDamage  ) {
	if (Event.Player != Null)
---OnFall---

//UpdateHitrate(Event.Shooter);
			XmlRpc::OnHit(Event);
		
	
	}
	
		else if (Event.Type == CSmModeEvent::EType::OnShoot ) {
---OnShoot---
//UpdateHitrate(Event.Shooter);
			XmlRpc::OnHit(Event);
		
	
	} 
	 
    // ---------------------------------- //
    // On Custom hit
    else if (Event.Type == CSmModeEvent::EType::OnActionCustomEvent) {
    if( Event.Shooter != Null && Event.Victim != Null)
    ---OnCHit---
    }
	
	else if (Event.Type == CSmModeEvent::EType::OnPlayerRemoved) {
	---OnPlayerDisconnect---
	}
	// ---------------------------------- //
	// On player request respawn
	else if (Event.Type == CSmModeEvent::EType::OnPlayerRequestRespawn) {
---OnRequestRespawn---
		XmlRpc::OnPlayerRequestRespawn(Event);
		
		
		
	} 
	// ---------------------------------- //
	// Others
	else {
		//PassOn(Event);
	}
}

if (Now > EndTime && EndTime > 0) {
MT_StopTurn(C_OverTime);
}

ManageCommand();

if (G_Override_NeedWarmUp) {
MB_Sleep(100);
UIManager.UIAll.BigMessage = "";
MB_Sleep(100);
G_WinningTurn = 0;
WarmUp2();
}	
***

***EndTurn***
***
if (!G_Override_NeedWarmUp) {
GoalAdv();
+++StartEndTurn+++

MT_Sleep(100);
EndTime = Now;
UIManager.UIAll.CountdownEndTime = -1;

MT_Sleep(800);
Message::CleanAllMessages();

MT_Sleep(1000);
SM::UnspawnAllPlayers();
if (G_WinningTurn == 1) ClanScores[1] += 1;
else ClanScores[2] += 1;

+++CompleteEndTurn+++

StartTime = -1;
EndTime = -1;

UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
MT_Sleep(200);

UpdateHeader();

if (Egality()) {
G_TiePoints += 1;
UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::TieBreakPoint;
UIManager.UIAll.BigMessageSoundVariant = G_TiePoints;
} else {
UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;
if (G_WinningTurn == G_AtkClan) UIManager.UIAll.BigMessageSoundVariant = 1;
else if (G_WinningTurn == G_DefClan) UIManager.UIAll.BigMessageSoundVariant = 0;
}
MT_Sleep(200*GetSleep());

G_ReasonMessage1 = TextLib::Compose(_("$<%1$> wins the turn!"), Teams[G_WinningTurn-1].ColorizedName);
if (G_AtkClan == G_WinningTurn && GetMode() >= 1) G_ReasonMessage1 = TextLib::Compose(_("$<%1$> wins the turn!"),
                                                   G_NextAtkName[1]);

if (G_ReasonMessage1 != "") UIManager.UIAll.BigMessage = G_ReasonMessage1;
if (G_ReasonMessage2 != "") UIManager.UIAll.StatusMessage = G_ReasonMessage2;

MT_Sleep(500*GetSleep());

UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;

MT_Sleep(2000*GetSleep());

UIManager.UIAll.BigMessage = "";
UIManager.UIAll.StatusMessage = "";

+++EndEndTurn+++ /* you wot? */

MT_Sleep(450*GetSleep());

UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;

Victory::SetMatchWinnerFromScore(S_Turn, S_TurnGap, S_TurnMax);

MT_Sleep(300);

if (Victory::IsMatchWinner(1)) MB_StopRound = True;
else if (Victory::IsMatchWinner(2)) MB_StopRound = True;
} else {
G_Override_NeedWarmUp = False;
Message::CleanAllMessages();
+++EndWarmupTurn+++
MB_Sleep(500);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UpdateHeader();
EndTime = -1;
StartTime = -1;
}

UIManager.UIAll.BigMessage = "";
UIManager.UIAll.GaugeMessage = "";
UIManager.UIAll.GaugeRatio = -1.;
UIManager.UIAll.GaugeClan = 0;
***

***EndRound***
***

	+++DeleteVarRound+++

MT_Sleep(500);
if (MT_QuickStop) MB_StopMap = True;
MB_StopMap = True;
***

***EndMap***
***

	+++DeleteVarMap+++
	
if (Victory::IsMatchWinner(1)) {
	UIManager.UIAll.BigMessage = TextLib::Compose("$<%1$> wins the map!",
		                                        Teams[0].ColorizedName); 
		if (S_MatchPoints > 0) {
		G_MapScores[1] += 1;
		UIManager.UIAll.StatusMessage = "$<"^Teams[0].ColorizedName^"$> "^G_MapScores[1]^" - "^G_MapScores[2]^" $<"^Teams[1].ColorizedName^"$>";
		} 
}
if (Victory::IsMatchWinner(2)) {
	UIManager.UIAll.BigMessage = TextLib::Compose("$<%1$> wins the map!",
		                                        Teams[1].ColorizedName);
		if (S_MatchPoints > 0) {
		G_MapScores[2] += 1;
		UIManager.UIAll.StatusMessage = "$<"^Teams[0].ColorizedName^"$> "^G_MapScores[1]^" - "^G_MapScores[2]^" $<"^Teams[1].ColorizedName^"$>";
		} 
}

UpdateHeader();

if (S_MatchPoints > 0) {
MT_Sleep(3000);
// ---------------------------------- //
// Draw
if (G_MapScores[1] == G_MapScores[2] && G_MapScores[1] >= S_MatchPoints) {
	UIManager.UIAll.BigMessage = _("|Match|Draw");
	MB_Log("""Draw Match {{{G_MapScores[1]}}}-{{{G_MapScores[2]}}}""");
	WinnerMatchClan = 0;
	MB_StopMatch = True;
}
// ---------------------------------- //
// Clan 1 wins with best score
else if (G_MapScores[1] >= S_MatchPoints) {
	UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> wins the match!"), Teams[0].ColorizedName);
	MB_Log("""Clan 1 wins the Match {{{G_MapScores[1]}}}-{{{G_MapScores[2]}}}""");
	WinnerMatchClan = 1;
	MB_StopMatch = True;
} 
// ---------------------------------- //
// Clan 2 wins with best score
else if (G_MapScores[2] >= S_MatchPoints) {
	UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> wins the match!"), Teams[1].ColorizedName);
	MB_Log("""Clan 2 wins the Match {{{G_MapScores[1]}}}-{{{G_MapScores[2]}}}""");
	WinnerMatchClan = 2;
	MB_StopMatch = True;
} 
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
MT_Sleep(1000*GetSleep());
} else UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
	
MT_Sleep(5000);

UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;

MT_Sleep(6000);

UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;

MT_Sleep(1000);

MT_Sleep(3000);

UIManager.UIAll.UISequence = CUIConfig::EUISequence::None;

MT_Sleep(10);
***

// ---------------------------------- //
/// Update the score summary header.
Void UpdateHeader() {
	declare CSmPlayer Player1 <=> Null;
	declare CSmPlayer Player2 <=> Null;
	declare HeaderClanScores = Integer[Integer];
	
	HeaderClanScores = [1 => G_MapScores[1], 2 => G_MapScores[2]];

	// Find a captain for each clan
	foreach (Player in Players) {
		if (Player.CurrentClan == 1) {
			Player1 <=> Player;
		} else if (Player.CurrentClan == 2) {
			Player2 <=> Player;
		}
	}
	
	UIManager.UIAll.OverlayScoreSummary = True;
	if (Player1 != Null) {
		UIManager.UIAll.ScoreSummary_Player1 = Player1.Id;
		UIManager.UIAll.ScoreSummary_Points1 = ClanScores[1];
		UIManager.UIAll.ScoreSummary_MatchPoints1 = HeaderClanScores[1];
	} else {
		UIManager.UIAll.ScoreSummary_Player1 = NullId;
		UIManager.UIAll.ScoreSummary_Points1 = 0;
		UIManager.UIAll.ScoreSummary_MatchPoints1 = 0;
	}

	if (Player2 != Null) {
		UIManager.UIAll.ScoreSummary_Player2 = Player2.Id;
		UIManager.UIAll.ScoreSummary_Points2 = ClanScores[2];
		UIManager.UIAll.ScoreSummary_MatchPoints2 = HeaderClanScores[2];
	} else {
		UIManager.UIAll.ScoreSummary_Player2 = NullId;
		UIManager.UIAll.ScoreSummary_Points2 = 0;
		UIManager.UIAll.ScoreSummary_MatchPoints2 = 0;
	}
	
	declare netwrite Clan1MapPoints for XmlRpc = 0;
	declare netwrite Clan1MatchPoints for XmlRpc = 0;
	declare netwrite Clan2MapPoints for XmlRpc = 0;
	declare netwrite Clan2MatchPoints for XmlRpc = 0;
	Clan1MapPoints = ClanScores[1];
	Clan1MatchPoints = HeaderClanScores[1];
	Clan2MapPoints = ClanScores[2];
	Clan2MatchPoints = HeaderClanScores[2];
}

Void Lost_Events() { }

Void MT_Sleep(Integer _Duration) {
   declare Start = Now;
   while(Now < Start + _Duration) {
      MB_Yield();
      Lost_Events();
   }

}

Void MT_Presentation(Integer _Duration) {
   declare Start = Now;
   while(Now < Start + _Duration) {
      MB_Yield();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::PlayersPresentation;
   }
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing ;

}


Void PlaySound(CUIConfig::EUISound _Sound, Integer _Variant) {
	UIManager.UIAll.SendNotice("", CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default, _Sound, _Variant);
}

// ---------------------------------- //
/// Manage #Command
Void ManageCommand() {
	foreach (Event in PendingEvents) {
		if (Event.Type == CSmModeEvent::EType::OnCommand) {
			switch (Event.CommandName) {
				// ---------------------------------- //
				case "Command_MatchPointsClan1": {
					if (Event.CommandValueInteger < 0) G_MapScores[1] = 0;
					else G_MapScores[1] = Event.CommandValueInteger;
					MB_SectionMapNb = G_MapScores[1] + G_MapScores[2] + 1;
					
					UpdateHeader();
				}
				// ---------------------------------- //
				case "Command_MatchPointsClan2": {
					if (Event.CommandValueInteger < 0) G_MapScores[2] = 0;
					else G_MapScores[2] = Event.CommandValueInteger;
					MB_SectionMapNb = G_MapScores[1] + G_MapScores[2] + 1;
					
					UpdateHeader();
				}
				// ---------------------------------- //
				case "Command_CurrentMapPointsClan1": {
					G_MatchPoints[1] -= ClanScores[1];
					if (Event.CommandValueInteger < 0) ClanScores[1] = 0;
					else ClanScores[1] = Event.CommandValueInteger;
					G_MatchPoints[1] += ClanScores[1];
					MB_SectionTurnNb = ClanScores[1] + ClanScores[2] + 1;
					
					UpdateHeader();
					MM_SetScores([ClanScores[1], ClanScores[2]]);
				}
				// ---------------------------------- //
				case "Command_CurrentMapPointsClan2": {
					G_MatchPoints[2] -= ClanScores[2];
					if (Event.CommandValueInteger < 0) ClanScores[2] = 0;
					else ClanScores[2] = Event.CommandValueInteger;
					G_MatchPoints[2] += ClanScores[2];
					MB_SectionTurnNb = ClanScores[1] + ClanScores[2] + 1;
					
					UpdateHeader();
					MM_SetScores([ClanScores[1], ClanScores[2]]);
				}
				// ---------------------------------- //
				case "Command_PreviousMapsPointsClan1": {
					if (Event.CommandValueInteger < 0) G_MatchPoints[1] = 0;
					else G_MatchPoints[1] = Event.CommandValueInteger;
					G_MatchPoints[1] += ClanScores[1];
				}
				// ---------------------------------- //
				case "Command_PreviousMapsPointsClan2": {
					if (Event.CommandValueInteger < 0) G_MatchPoints[2] = 0;
					else G_MatchPoints[2] = Event.CommandValueInteger;
					G_MatchPoints[2] += ClanScores[2];
				}
				// ---------------------------------- //
				case "Command_ForceFirstAtkClan": {
					if (Event.CommandValueInteger == 1 || Event.CommandValueInteger == 2) G_Override_FirstAtkClan = Event.CommandValueInteger;
				}
				// ---------------------------------- //
				case "Command_ForceG_TossWinner": {
					if (Event.CommandValueInteger == 1 || Event.CommandValueInteger == 2) G_Override_G_TossWinner = Event.CommandValueInteger;
				}
				// ---------------------------------- //
				case "Command_ForceWarmUp": {
					if (Event.CommandValueBoolean) {
						G_Override_NeedWarmUp = True;
					}
				}
				// ---------------------------------- //
				case "Command_ForceClublinkReload": {
					if (Event.CommandValueBoolean) {
						G_Override_ForceClublinkReload = True;
					}
				}
			}
		}
	}
}

Void ForceClublinkReload() {
	if (!G_Override_ForceClublinkReload) return;
	G_Override_ForceClublinkReload = False;
	
	Clublink::ResetAll();
	Clublink::DefineTeamAuto(True);
}

Integer GetMode() {
	declare Mode = S_Mode;
	if (Mode != 0 && Mode != 1) Mode = 0;
	return Mode;
}

Void InitBasesColor() {
	foreach (Base in MapBases) {
		Base.Clan = G_DefClan;
		Base.IsActive = True;
	}
	
	// Get def and atk spawn
	declare DefSpawn <=> Map::GetLandmarkPlayerSpawn("SpawnDefense", 0);
	declare AtkSpawn <=> Map::GetLandmarkPlayerSpawn("SpawnAttack", 0);
	
	// Color the bases
	if (DefSpawn.Base != AtkSpawn.Base && DefSpawn.Base != Null && AtkSpawn.Base != Null) {
		AtkSpawn.Base.Clan = G_AtkClan;
		AtkSpawn.Base.IsActive = True;
	}
}


Void SpawnThemAll() {
	// Get def and atk spawn
	declare DefSpawn <=> Map::GetPlayerSpawn("SpawnDefense", 0);
	declare AtkSpawn <=> Map::GetPlayerSpawn("SpawnAttack", 0);
	
	// WarmUp classic/free || Waiting time
		foreach (Player in Players) {	
			declare WarmUpSide for Player = True;
			if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) continue;
			
			SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_WURocketAmmoMax);
			SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, C_WULaserAmmoMax);
			SetPlayerAmmoMax(Player, CSmMode::EWeapon::Nucleus, C_WUNucleusAmmoMax);
			Player.ArmorMax	= 300;
			if (WarmUpSide) {
				Player.AmmoGain	= 1. * C_WULaserAmmoGain;
				Player.StaminaMax = 1.;
				Player.StaminaGain = 1.;
				
				SetPlayerWeapon(Player, CSmMode::EWeapon::Laser, False);
				SM::SpawnPlayer(Player, MM_GetRequestedClan(Player), Player.ArmorMax, AtkSpawn, Now);
				SetPlayerAmmo(Player, CSmMode::EWeapon::Nucleus, C_WUNucleusAmmoMax);
			} else {
				Player.AmmoGain	= 1. * C_WURocketAmmoGain;
				Player.StaminaMax = 1. * C_DefStaminaMaxMultiplier;
				Player.StaminaGain = 1. * C_DefStaminaMaxMultiplier;
				SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, True);
				SM::SpawnPlayer(Player, MM_GetRequestedClan(Player), Player.ArmorMax, DefSpawn, Now);
				SetPlayerAmmo(Player, CSmMode::EWeapon::Nucleus, C_WUNucleusAmmoMax);
			}
			Player.IsHighlighted = True;
			WarmUpSide = !WarmUpSide;
	} 	
	
	InitBasesColor();
}

Void UpdateSpectators(Boolean _Forced) {
	if (!_Forced && G_LastSpecUpdate + 250 > Now) return;
	G_LastSpecUpdate = Now;
	UIManager.UIAll.SpectatorCamAutoLongitude = MathLib::Atan2(-G_MapSpecCamDirection.X, -G_MapSpecCamDirection.Z);
	UIManager.UIAll.SpectatorCamAutoLatitude = 0.5;
	
	UIManager.UIAll.SpectatorAutoTarget = G_Attackers[1];
	
	declare SpecDefId = NullId;
	foreach (Player in Players) {
		if (Player.CurrentClan == G_DefClan && Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
			SpecDefId = Player.Id;
		}
	}
	
	foreach (Player in Players) {		
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		
		// Can select defender to spec
		if (Player.CurrentClan != 0) {
			UI.SpectatorForceCameraType = 1;
			UI.SpectatorForcedClan = Player.CurrentClan;
		} else if (MM_GetRequestedClan(Player) != 0) {
			UI.SpectatorForceCameraType = 1;
			UI.SpectatorForcedClan = MM_GetRequestedClan(Player);
		} else {
			UI.SpectatorForceCameraType = -1;
			UI.SpectatorForcedClan = -1;
		}
		
		declare PrevSpectatorForcedClan for UI = -1;
		PrevSpectatorForcedClan = UI.SpectatorForcedClan;
	}
	
	foreach (Spectator in Spectators) {
		declare UI <=> UIManager.GetUI(Spectator);
		if (UI == Null) continue;
			
		if (UI.SpectatorForceCameraType >= 0 || UI.SpectatorForcedClan >= 0) {
			UI.SpectatorForceCameraType = -2;
			UI.SpectatorForcedClan = -2;
			
			declare PrevSpectatorForcedClan for UI = -1;
			if (PrevSpectatorForcedClan != UI.SpectatorForcedClan) {
				PrevSpectatorForcedClan = UI.SpectatorForcedClan;
					UIManager.UIAll.SendChat(TextLib::Compose("$<%1$> goes into spectator mode", Spectator.Name));
			}
		}
	}
}
Void UpdateSpectators() {
	UpdateSpectators(False);
}

Void NoticeHitDistance(CSmPlayer _Player, Text _Message) {
	declare UI <=> UIManager.GetUI(_Player);
	Message::SendBigMessage(_Player, _Message, 2000, 2);
}

Void DisplayHitDistance(CSmPlayer _Shooter, CSmPlayer _Victim, Boolean _ShooterOnly) {
	if (_Shooter == Null || _Victim == Null) return;
	
	declare Distance = MathLib::Distance(_Shooter.Position, _Victim.Position);
	Distance = MathLib::NearestInteger(Distance*10.0)/10.0;
	declare DistanceText = TextLib::SubString(TextLib::ToText(Distance), 0, 5);
	declare DistanceSplit = TextLib::Split(".", DistanceText);
	if (DistanceSplit.count == 1) DistanceText = DistanceSplit[0];
	declare DistanceMessage = TextLib::Compose(_("%1m hit!"), DistanceText);
	if (_ShooterOnly) {
		NoticeHitDistance(_Shooter, DistanceMessage);
	} else {
		foreach (Player in Players) {
			if (Player.CurrentClan == G_AtkClan) {
				NoticeHitDistance(Player, DistanceMessage);
			}
		}
		foreach (Spectator in Spectators) {
			NoticeHitDistance(Spectator, DistanceMessage);
		}
		if (Distance > G_LongestRailDistance) {
			G_LongestRailName = _Shooter.Name;
			G_LongestRailDistance = Distance;
		}
	}
}


Void WarmUp2() {
	XmlRpc::BeginWarmUp();
	+++StartWarmUp+++
	
	if (MB_UseScriptCallbacks && XmlRpc::CallbackIsAllowed("BeginWarmup")) XmlRpc::SendCallback("BeginWarmup", Json::Enfold(Json::Stringify("AllReady", False)));
	
	// Shutdown the poles during warmup
	foreach (Goal in MapLandmarks_Gauge) {
		Goal.Gauge.Clan = 0;
		Goal.Gauge.Speed = 0;
		Goal.Gauge.Value = 0;
		Goal.Gauge.Max = 1000;
		Goal.Gauge.Captured = False;
	}
	SM::UnspawnAllPlayers();
	
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Silence;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	UIManager.UIAll.StatusMessage = _("Press F6 once you're ready.");
	if (G_Override_NeedWarmUp) UIManager.UIAll.BigMessage = TextLib::Compose("$f90%1", _("Pause"));
	else UIManager.UIAll.BigMessage = TextLib::Compose("$f90%1", _("Warm-up"));
	PlaySound(CUIConfig::EUISound::PhaseChange, 0);
	
	WarmUp2::Begin();
	
	// Init players
	foreach (Player in Players) {
		SetPlayerClan(Player, MM_GetRequestedClan(Player));
		if (Player.CurrentClan == 1) WarmUp2::SetPlayerGroup(Player, "Clan1");
		else if (Player.CurrentClan == 2) WarmUp2::SetPlayerGroup(Player, "Clan2");
	}
	WarmUp2::Fill();
	
	declare PrevWarmUpDuration = S_WarmUpDuration-1;
	declare PrevMode = -1;
	
	while (!WarmUp2::Stop()) {
		MM_Yield();
		ManageCommand();
		ForceClublinkReload();
		
		// Let the server sleep if there's no players on it
		if (PlayersNbTotal <= 0) continue;
		
		foreach (Player in Players) {
			if (Player.CurrentClan != MM_GetRequestedClan(Player)) {
				UnspawnPlayer(Player);
				SetPlayerClan(Player, MM_GetRequestedClan(Player));
				if (Player.CurrentClan == 1) WarmUp2::SetPlayerGroup(Player, "Clan1");
				else if (Player.CurrentClan == 2) WarmUp2::SetPlayerGroup(Player, "Clan2");
			}
		}
		
		if (PrevMode != GetMode() || PrevWarmUpDuration != S_WarmUpDuration) {
			PrevMode = GetMode();
			PrevWarmUpDuration = S_WarmUpDuration;
			
			declare LongTimer = S_WarmUpDuration*1000;
			declare ShortTimer = 5000;
			if (LongTimer <= 0) { LongTimer = 0; ShortTimer = 0; }
			
			if (GetMode() == 0) {
				WarmUp2::SetGroupTimers("Clan1", [ShortTimer => [-1, S_NbPlayersPerTeamMax], LongTimer => [1, S_NbPlayersPerTeamMax]]);
				WarmUp2::SetGroupTimers("Clan2", [ShortTimer => [-1, S_NbPlayersPerTeamMax], LongTimer => [1, S_NbPlayersPerTeamMax]]);
			} else {
				WarmUp2::SetGroupTimers("Clan1", [ShortTimer => [-1, 1], LongTimer => [1, 1]]);
				WarmUp2::SetGroupTimers("Clan2", [ShortTimer => [-1, 1], LongTimer => [1, 1]]);
			}
		}
		
		WarmUp2::Loop();
		SpawnThemAll();
		UpdateSpectators();
		
		if (WarmUp2::Updated()) {
			Clublink::DefineTeamAuto(True);
		}
		
		WarmUp2::ManageEvents();
		foreach (Event in PendingEvents) {
			if (Event.Type == CSmModeEvent::EType::OnHit && Event.Victim != Null && Event.WeaponNum == C_WeaponLaser) {
				DisplayHitDistance(Event.Shooter, Event.Victim, True);
			}
		}
	}
	
	WarmUp2::End();
	
	if (MB_UseScriptCallbacks && XmlRpc::CallbackIsAllowed("EndWarmup")) XmlRpc::SendCallback("EndWarmup", Json::Enfold(Json::Stringify("AllReady", True)));
	
	PlaySound(CUIConfig::EUISound::StartMatch, 0);
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::PhaseChange;
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
	UIManager.UIAll.StatusMessage = "";
	UIManager.UIAll.BigMessage = "";
	SM::UnspawnAllPlayers();
	
	// ---------------------------------- //
	// Update the players clublinks
	Clublink::DefineTeamAuto();
	Clublink::SyncUpdate();
	
	//Layers::Update("ScoresTable", CreateLayerScoresTable());
	
	+++EndWarmUp+++
	XmlRpc::EndWarmUp();
}

Void MT_StopRound(Integer _Reason) {
	if (_Reason == C_NoGoals) {
	    G_Reason = _Reason;
		MT_QuickStop = True;
		MB_StopRound = True;
	}
}

Void MT_StopTurn(Integer _Reason) {
G_Reason = _Reason;
MB_StopTurn = True;
if (_Reason == C_DefElimination) {
     G_ReasonMessage2 = _("All defenders eliminated.");
	 G_WinningTurn = G_AtkClan;
	}
if (_Reason == C_AtkElimination) {
     G_ReasonMessage2 = _("All attackers eliminated.");
	 G_WinningTurn = G_DefClan;
	}
if (_Reason == C_UltimateElimination) {
     G_ReasonMessage2 = _("Attacker eliminated.");
	 G_WinningTurn = G_DefClan;
	}
if (_Reason == C_GoalCaptured) {
     G_ReasonMessage2 = _("Goal captured.");
	 G_WinningTurn = G_AtkClan;
	}
if (_Reason == C_GoalsCaptured) {
     G_ReasonMessage2 = _("Goals captured.");
	 G_WinningTurn = G_AtkClan;
	}
if (_Reason == C_OverTime) {
     G_ReasonMessage2 = _("Time limit reached.");
	 G_WinningTurn = G_DefClan;
	}
}

Integer GetSleep() {
	if (S_QuickMode) {
		return 1;
	} else return 2;
	
	return 0;
}

Integer DefClan() {
 log(3-G_AtkClan);
 return 3-G_AtkClan;
}

Void AtkSlot(Integer _GamePlay) {
declare Clan = "Clan1";
if (G_AtkClan == 2) Clan = "Clan2";
declare SlotNb = WarmUp2::GetSlotsNb(Clan);
declare I = 0;
declare ChampionsSlots = 0;

G_Attackers[1] = NullId;
G_Attackers[2] = NullId;
G_NextAtkName[1] = "ERROR";
G_NextAtkName[2] = "ERROR";

declare NoName = 1;

declare F_Gameplay = 1;

log(_GamePlay^" < Gameplay");

if (_GamePlay == C_GEs) F_Gameplay = 1;
else F_Gameplay = 2;

while (True) {
	if (G_AtkSlot[G_AtkClan][F_Gameplay] > S_NbPlayersPerTeamMax) G_AtkSlot[G_AtkClan][F_Gameplay] = 1;
	
	declare PlayerId = WarmUp2::GetSlot(Clan, G_AtkSlot[G_AtkClan][F_Gameplay]);
	if (PlayerId != NullId && Players.existskey(PlayerId)) {
	if (F_Gameplay == 2) {
	while (ChampionsSlots < F_Gameplay) {
	    ChampionsSlots += 1;
		G_NextAtkName[ChampionsSlots] = Players[PlayerId].Name;
		if (ChampionsSlots == 1) G_Attackers[1] = PlayerId;
		else G_Attackers[2] = PlayerId;
		declare netwrite Net_Elite_AtkLogin for Teams[0] = "";
		declare netwrite Net_Elite_AtkSponsors for Teams[0] = Text[];
		Net_Elite_AtkLogin = Players[PlayerId].Login;
		log(G_NextAtkName[NoName]);
		log(ChampionsSlots);
		break;
	}
	} else {
		ChampionsSlots += 1;
		G_NextAtkName[ChampionsSlots] = Players[PlayerId].Name;
		if (ChampionsSlots == 1) G_Attackers[1] = PlayerId;
		else G_Attackers[2] = PlayerId;
		declare netwrite Net_Elite_AtkLogin for Teams[0] = "";
		declare netwrite Net_Elite_AtkSponsors for Teams[0] = Text[];
		Net_Elite_AtkLogin = Players[PlayerId].Login;
		log(G_NextAtkName[NoName]);
		log(ChampionsSlots);
		break;
	}
}
	
	G_AtkSlot[G_AtkClan][F_Gameplay] += 1;
	I += 1;
	if (I >= SlotNb) break;
}
}

Void SpawnPlayers() {

declare OrderDef = Ident[Integer];
declare OrderAtk = Ident[Integer];
declare DefSpawn <=> Map::GetPlayerSpawn("SpawnDefense", 0);
declare AtkSpawn <=> Map::GetPlayerSpawn("SpawnAttack", 0);
AtkSpawned = 0;
DefSpawned = 0;
declare MaxDef = S_NbPlayersPerTeamMax;
declare MaxAtk = S_NbPlayersPerTeamMax;

if (G_Gameplay == 0) MaxAtk = 1;
else MaxAtk = MaxDef;

	if (G_AtkClan == 1) {
		OrderDef = WarmUp2::GetGroup("Clan2");
		OrderAtk = WarmUp2::GetGroup("Clan1");
	} else if (G_AtkClan == 2) {
		OrderDef = WarmUp2::GetGroup("Clan1");
		OrderAtk = WarmUp2::GetGroup("Clan2");
	}	
	foreach (Slot => PlayerId in OrderDef) {
		+++SpawnDef+++
}
	foreach (Slot => PlayerId in OrderAtk) {
		+++SpawnAtk+++
	}
}

Boolean AtkEliminated() {
foreach (Player in Players) {
	if (Player.Id == G_Attackers[1]) {
		if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) return True;
	}
	if (G_Gameplay != C_GEs && Player.Id == G_Attackers[2]) {
		if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) return True;
	}
}
return False;
}

Void GoalAdv() {
declare GaugeValue = 0;
declare MostActivatedGoal <=> CSmMapLandmark;
foreach (Goal in MapLandmarks_Gauge) {
log(Goal.Gauge.Clan);
	Goal.Gauge.Speed = 0;

	if (Goal.Gauge.Clan == G_AtkClan && Goal.Gauge.Value > GaugeValue) {
	    log("oui");
		GaugeValue = Goal.Gauge.Value;
		MostActivatedGoal <=> Goal;
	}
}
if (MostActivatedGoal != Null
	&& MostActivatedGoal.Gauge.Value > 0 
	&& G_Reason != C_GoalCaptured
) {
	if (MostActivatedGoal.Gauge.ValueReal >= 1.) UIManager.UIAll.GaugeRatio = 0.99;
	else UIManager.UIAll.GaugeRatio = MostActivatedGoal.Gauge.ValueReal;
	UIManager.UIAll.GaugeClan = MostActivatedGoal.Gauge.Clan;
	UIManager.UIAll.GaugeMessage = "" ^ MathLib::FloorInteger(UIManager.UIAll.GaugeRatio*100) ^ "%";
}
}

Boolean Egality() {
for (Clan, 1, 2) {
if ((ClanScores[Clan] >= S_Turn) || (ClanScores[Clan] >= S_Turn && ClanScores[Clan] - ClanScores[3-Clan] >= S_TurnGap)) {
return True;
} else return False;
}
return False;
}

Void DoToss() {
if (!MM_IsMatchmakingServer() && MB_SectionTurnNb <= 1) {
	declare DecisiveMap = False;
	if (G_MapScores[1] == S_MatchPoints - 1 && G_MapScores[2] == S_MatchPoints - 1) DecisiveMap = True;
	
	// Override the toss winner
	if (G_Override_G_TossWinner == 1 || G_Override_G_TossWinner == 2) {
		if (MB_SectionMapNb == 1) {
			if (G_TossWinner == -1) G_VoteClanNb = G_Override_G_TossWinner;
			else {
				G_TossWinner = G_Override_G_TossWinner;
				G_VoteClanNb = 3 - G_TossWinner;
			}
		} else {
			if (MB_SectionMapNb % 2 == 0) {
				G_VoteClanNb = 3 - G_Override_G_TossWinner;
			} else {
				G_VoteClanNb = G_Override_G_TossWinner;
			}
		}
		G_Override_G_TossWinner = -1;
	} else {
		// Play the toss
		if (MB_SectionMapNb == 1) {
			if (G_TossWinner == -1) G_VoteClanNb = Toss::Toss();
			else G_VoteClanNb = 3 - G_TossWinner;	///< The looser of the map selection toss
		}
	}
	
	// Override the side selection
	if (G_Override_FirstAtkClan == 1 || G_Override_FirstAtkClan == 2) {
		G_AtkClan = G_Override_FirstAtkClan;
		G_DefClan = 3 - G_AtkClan;
		G_FirstAtk = G_Override_FirstAtkClan;
		G_Override_FirstAtkClan = -1;
	}
	// Vote for side
	else {
		declare SelectedSide = Toss::SelectSide(G_VoteClanNb);
		if (SelectedSide == 1) {
			G_AtkClan = G_VoteClanNb;
			G_DefClan = 3 - G_VoteClanNb;
		} else if (SelectedSide == 2) {
			G_AtkClan = 3 - G_VoteClanNb;
			G_DefClan = G_VoteClanNb;
		}
	}
	G_VoteClanNb = 3 - G_VoteClanNb;
}
}
